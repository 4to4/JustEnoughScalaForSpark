{
  "metadata" : {
    "name" : "Just Enough Scala for Spark",
    "user_save_timestamp" : "1970-01-01T01:00:00.000Z",
    "auto_save_timestamp" : "1970-01-01T01:00:00.000Z",
    "language_info" : {
      "name" : "scala",
      "file_extension" : "scala",
      "codemirror_mode" : "text/x-scala"
    },
    "trusted" : true,
    "customLocalRepo" : null,
    "customRepos" : null,
    "customDeps" : null,
    "customImports" : null,
    "customArgs" : null,
    "customSparkConf" : null
  },
  "cells" : [ {
    "metadata" : {
      "id" : "DB7A35849BCB4167802DB59D5CA868E8"
    },
    "cell_type" : "markdown",
    "source" : "# Just Enough Scala for Spark\n\n[Dean Wampler, Ph.D.](mailto:dean.wampler@lightbend.com)<br/>\n[@deanwampler](http://twitter.com/deanwampler)\n\nWelcome. This notebook teaches you the core concepts of [Scala](http://scala-lang.org) necessary to use [Apache Spark's](http://spark.apache.org) Scala API effectively. Spark does a nice job exploiting the nicest features of Scala, while avoiding most of the more difficult and obscure features. "
  }, {
    "metadata" : {
      "id" : "FEB41A56E21F408A966052A75B819C8E"
    },
    "cell_type" : "markdown",
    "source" : "## Introduction: Why Scala?\nSpark lets you use Scala, Java, Python, R, and SQL to do your work. Scala and Java appeal to _data engineers_, who do the heavy lifting of building resilient and scalable infrastructures for _Big Data_. Python, R, and SQL appeal to _data scientists_, who build models for analyzing data, including machine learning, as well as explore data interactively, where SQL is very convenient.\n\nThese aren't hard boundaries. Many people do both roles. Many data engineers like Python and may use SQL and R. Many data scientists have decided to use Scala with Spark.\n\nBriefly, some of the advantages of using Scala include the following:\n* **Performance:** Since Spark is written in Scala, you get the best performance and the most complete API coverage when you use Scala. It's true that with [DataFrames](http://spark.apache.org/docs/latest/sql-programming-guide.html), code written in all five languages performs about the same. If you need to use the [RDD](http://spark.apache.org/docs/latest/programming-guide.html#resilient-distributed-datasets-rdds) API, then Scala provides the best performance, with Java a close second.\n* **Debugging:** When runtime problems occur, understanding the exception stack frames and other debug information is easiest if you know Scala. Unfortunately, the \"abstraction leaks\" when problems occur.\n* **Concise, Expressive Code:** Compared to Java, Scala code is much more concise and several features of Scala make your code even more concise. This elevates your productivity and makes it easier to imagine a design approach and then write it down without having to translate the idea to a less flexible API that reflects idiomatic language constraints. (You'll see this in action as we go.)\n* **Type Safety:** Compared to Python and R, Scala code benefits from _static typing_ with _type inference_. _Static typing_ means that the Scala parser finds more errors in your expressions at compile time, when they don't match expected types, rather than discovering the problem later at run time. However, _type inference_ means you don't have to add a lot of explicit type information to you code. In most cases, Scala will infer the correct types for you."
  }, {
    "metadata" : {
      "id" : "643793D69BF84D788D14E50DBE1CED14"
    },
    "cell_type" : "markdown",
    "source" : "### Why Not Scala?\nScala isn't perfect. There are two disadvantages compared to Python and R:\n* **Libraries:** Python and R have a rich ecosystem of data analytics libraries. While the picture is improving for Scala, Python and R are still well ahead.\n* **Advanced Language Features:** Mastering advanced language features gives you a lot of power to exploit, but if you don't understand those features, they can get in your way when you're just trying to get work done. Scala has some sophisticated constructs, especially in its _type system_. Fortunately, Spark mostly hides the advanced constructs."
  }, {
    "metadata" : {
      "id" : "1D3A90B8EB19432E9D569E0BDF099FA8"
    },
    "cell_type" : "markdown",
    "source" : "### For More on Scala\nI can only scratch the surface of Scala here. We'll \"sketch\" concepts without too much depth. You'll learn enough to make use of them, but eventually you'll want to deepen your understanding.\n\nWhen you need more information, consider these resources:\n\n* [Programming Scala, Second Edition](http://shop.oreilly.com/product/0636920033073.do): My comprehensive introduction to Scala.\n* [Scala Language Website](http://scala-lang.org/): Where to download Scala, find documentation (e.g., the [Scaladocs](http://www.scala-lang.org/api/current/#package): Scala library documentation, like [Javadocs](https://docs.oracle.com/javase/8/docs/api/)), and other information.\n* [Lightbend](http://www.lightbend.com/services/) training, consulting, and support for Scala, Big Data tools like Spark, and the [Lightbend Reactive Platform](http://www.lightbend.com/products/lightbend-reactive-platform).\n\nFor now, I recommend that you open the Scaladocs for Scala and for Spark's Scala API. Clicking these two links will open them in new browser tabs:\n* Scaladocs for <a href=\"http://www.scala-lang.org/api/current/#package\" target=\"scala_scaladocs\">Scala</a>.\n* Scaladocs for <a href=\"http://spark.apache.org/docs/latest/api/scala/index.html#package\" target=\"spark_scaladocs\">Spark</a>."
  }, {
    "metadata" : {
      "id" : "09039ABE472F4B09AA5969B8FAA7E2BD"
    },
    "cell_type" : "markdown",
    "source" : "> **Tips for using Scaladocs:**\n* Use the search bar in the upper-left-hand side to find a particular _type_. (For example, try \"RDD\" in the Spark Scaladocs.) \n* To search for a particular _method_, click the character under the search box for the method name's first letter, then scroll to it."
  }, {
    "metadata" : {
      "id" : "40AA3A2B596F44CBB4955A0F282E6D28"
    },
    "cell_type" : "markdown",
    "source" : "## About Notebooks\nYou're using the [Spark Notebook](http://spark-notebook.io/) environment, a Scala-centric fork of [iPython](https://ipython.org/) configured for [Apache Spark](http://spark.apache.org).\n\nNotebooks let you mix documentation, like this [Markdown](https://daringfireball.net/projects/markdown/) \"cell\", with cells that contain code, graphs of results, etc. The metaphor is a physical notebook a scientist or student might use while working in a laboratory.\n\nThe menus and toolbar at the top provide options for evaluating a cell, adding and deleting cells, etc. You'll want to learn keyboard shortcuts if you use notebooks a lot."
  }, {
    "metadata" : {
      "id" : "5A1E9EC40F5A423A8C42B542CD7D6378"
    },
    "cell_type" : "markdown",
    "source" : "> **Tips:**\n\n> Invoke the _Help > Keyboard Shortcuts_ menu item, then capture the page as an image (it's a modal dialog, unfortunately). Learn a few shortcuts each day.\n\n> For now, just know that you can click into any cell to move the focus. When you're in a cell, `shift+enter` evaluates the cell (parses and renders the Markdown or runs the code), then moves to the next cell. Try it for a few cells. I'll wait...\n\n> Finally, right click the _open SparkUI_ link in the right-hand sidebar, to see more information about what your Spark jobs are doing. If you want to hide the sidebar, use the _View > Hide/unhide sidebar_ menu item."
  }, {
    "metadata" : {
      "id" : "1085BD83DF844ADC87E5E73DC4F419B6"
    },
    "cell_type" : "markdown",
    "source" : "Okay. It's particularly nice that you can edit a cell you've already evaluated and rerun it. This is great when you're experimenting with code."
  }, {
    "metadata" : {
      "id" : "25BC8DA67F874D09836EE3400D876755"
    },
    "cell_type" : "markdown",
    "source" : "When you start this notebook, Spark Notebook creates a [SparkContext](http://spark.apache.org/docs/latest/programming-guide.html#initializing-spark) for you. This is the entry point of any Spark application. It knows how to connect to your cluster (or run locally in the same JVM), how to configure properties, etc. It also runs a Web UI that lets you monitor your running jobs. The instance of `SparkContext` is called `sc`. The next cell simply confirms that it exists. (The next cell is also our first `code` cell.)"
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "id" : "EE12AC334C4F4DEA957BDC14070B3468"
    },
    "cell_type" : "code",
    "source" : "sc",
    "outputs" : [ {
      "name" : "stdout",
      "output_type" : "stream",
      "text" : "res1: org.apache.spark.SparkContext = org.apache.spark.SparkContext@40800265\n"
    }, {
      "metadata" : { },
      "data" : {
        "text/html" : "org.apache.spark.SparkContext@40800265"
      },
      "output_type" : "execute_result",
      "execution_count" : 1
    } ]
  }, {
    "metadata" : {
      "id" : "8C9131CF1E354A2CB9103CA66C6470E9"
    },
    "cell_type" : "markdown",
    "source" : "Here are few other bits of information we can get from the `SparkContext`:"
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "id" : "02BE99E15B5245FBB07CE38840FC7DB4"
    },
    "cell_type" : "code",
    "source" : "println(\"Spark version:      \" + sc.version)\nprintln(\"Spark master:       \" + sc.master)\nprintln(\"Running 'locally'?: \" + sc.isLocal)",
    "outputs" : [ {
      "name" : "stdout",
      "output_type" : "stream",
      "text" : "Spark version:      1.6.2\nSpark master:       local[*]\nRunning 'locally'?: true\n"
    }, {
      "metadata" : { },
      "data" : {
        "text/html" : ""
      },
      "output_type" : "execute_result",
      "execution_count" : 2
    } ]
  }, {
    "metadata" : {
      "id" : "06B794609083404EB53553A5C98FF1E5"
    },
    "cell_type" : "markdown",
    "source" : "## Let's Download Some Data (and Start Learning Scala)\nWe're going to write real Spark programs and use them as vehicles for learning Scala and how to use it with Spark.\n\nBut first, we need to download some text files we'll use, which contain some of the plays of Shakespeare. The next few cells define some helper methods (functions) to do this and then perform the download. We'll start learning Scala concepts as we go."
  }, {
    "metadata" : {
      "id" : "D43407B76FEB47138B4C172B8686399A"
    },
    "cell_type" : "markdown",
    "source" : "> **Note:** \"method\" vs. \"function\"\n\n> Scala follows a common object-oriented convention where the term _method_ is used for a function that's attached to a class or instance. Unlike Java, at least before Java 8, Scala also has _functions_ that are not associated with a particular class or instance. \n\n> In our next code example, we'll define a few helper _methods_ for printing information, but you won't see a class definition here. So, what class is associated with these methods? When you use Scala in a notebook, you're actually using the Scala interpreter, which wraps any expressions and definitions we write into a hidden, generated class. The interpreter has to do this in order to generate valid JVM byte code. \n\n> Unfortunately, it can be a bit confusing when to use a method vs. a function, reflecting Scala's hybrid nature as an object-oriented and a functional language. Fortunately, in many cases, we can use methods and functions interchangably, so we won't worry about the distinction too much from now on.\n\n> We're defining methods now. We'll see what a real _function_ looks like soon."
  }, {
    "metadata" : {
      "id" : "9EB0F4904E62411ABB4732FCE434F3E2"
    },
    "cell_type" : "markdown",
    "source" : "Okay, here are two convenience methods for printing either an error message or a simple \"information\" message. We'll explain the syntax in a subsequent cell below."
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "id" : "CEDDE3DA00584FD091761BB897BA76B8"
    },
    "cell_type" : "code",
    "source" : "/*\n * \"info\" takes a single String argument, prints it on a line,\n * and returns it. \n */\ndef info(message: String): String = {\n    println(message)\n    message  // No additional formatting\n}",
    "outputs" : [ {
      "name" : "stdout",
      "output_type" : "stream",
      "text" : "info: (message: String)String\n"
    }, {
      "metadata" : { },
      "data" : {
        "text/html" : ""
      },
      "output_type" : "execute_result",
      "execution_count" : 6
    } ]
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "id" : "10CDCBBDF9B0414381D29AA57001B4FE"
    },
    "cell_type" : "code",
    "source" : "/*\n * \"error\" takes a single String argument, prints a formatted error message,\n * and returns the message. \n */\ndef error(message: String): String = {   \n    \n    // Print the string passed to \"println\" and add a linefeed (\"ln\"):\n    // See the next cell for an explanation of how the string is constructed.\n    val fullMessage = s\"\"\"\n        |********************************************************************\n        |\n        |  ERROR: $message\n        |\n        |********************************************************************\n        |\"\"\".stripMargin\n    println(println)\n    \n    // The last expression in a block, {...}, is the return value. \n    // The \"return\" keyword is not needed.\n    fullMessage\n}",
    "outputs" : [ {
      "name" : "stdout",
      "output_type" : "stream",
      "text" : "error: (message: String)String\n"
    }, {
      "metadata" : { },
      "data" : {
        "text/html" : ""
      },
      "output_type" : "execute_result",
      "execution_count" : 5
    } ]
  }, {
    "metadata" : {
      "id" : "803A3B24EDA44D8E8D0387961CED80C0"
    },
    "cell_type" : "markdown",
    "source" : "Let's try them:"
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "id" : "094980E7109040EA916AFE8EAA902C35"
    },
    "cell_type" : "code",
    "source" : "info(\"All is well.\")",
    "outputs" : [ {
      "name" : "stdout",
      "output_type" : "stream",
      "text" : "All is well.\nres11: String = All is well.\n"
    }, {
      "metadata" : { },
      "data" : {
        "text/html" : "All is well."
      },
      "output_type" : "execute_result",
      "execution_count" : 7
    } ]
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "id" : "AAF85354A9654E22A53B00546A0CAA29"
    },
    "cell_type" : "code",
    "source" : "error(\"Uh oh!\")",
    "outputs" : [ {
      "name" : "stdout",
      "output_type" : "stream",
      "text" : "\n()\nres7: String =\n\"\n********************************************************************\n\n  ERROR: Uh oh!\n\n********************************************************************\n\"\n"
    }, {
      "metadata" : { },
      "data" : {
        "text/html" : "\n********************************************************************\n\n  ERROR: Uh oh!\n\n********************************************************************\n"
      },
      "output_type" : "execute_result",
      "execution_count" : 5
    } ]
  }, {
    "metadata" : {
      "id" : "5CBE146ACD0B4212AB27E476DB571F7E"
    },
    "cell_type" : "markdown",
    "source" : "Method definitions have the following elements, in order:\n* The `def` keyword.\n* The method's name (`error` and `info` here).\n* The argument list in parentheses. If there are no arguments, the empty parentheses can be omitted. This is common for `toString` and \"getter\"-like methods that simply return a field in an instance, etc.\n* A colon followed by the type of the value returned by the method. This can often be inferred by Scala, so it's optional, but recommended for readibility by users!\n* An `=` (equals) sign that separates the method _signature_ from the _body_.\n* The body in braces `{ ... }`, although if the body consists of a single expression, the braces are optional.\n* The last expression in the body is used as the return value. The `return` keyword is optional and rarely used.\n* Semicolons (`;`) are inferred at the end of lines (in most cases) and rarely used."
  }, {
    "metadata" : {
      "id" : "CD393F164BDA4FA883DC4B8A5D00AE09"
    },
    "cell_type" : "markdown",
    "source" : "Look at the argument list for `error`. It is `(message: String)`, where `message` is the argument name and its type is `String`. This convention for _type annotations_, `name: Type`, is also used for the return type, `error(...): String`. Type annotations are required by Scala for method arguments. They are optional in most cases for the return type. We'll see that Scala can infer the types of many expressions and variable declarations.\n\nScala uses the same comment conventions as Java, `// ...` for a single line, and `/* ... */` for a comment block."
  }, {
    "metadata" : {
      "id" : "5755E06B4F334463BB852AD280667B3B"
    },
    "cell_type" : "markdown",
    "source" : "> **Note:** Expression vs. Statement\n\n> An _expression_ has a value, while a _statement_ does not. Hence, when we assign an expression to a variable, the value the expression returns is assigned to the variable."
  }, {
    "metadata" : {
      "id" : "2F67CEA53FCC4CD78E60C8471C77C032"
    },
    "cell_type" : "markdown",
    "source" : "Inside `error`, we used a combination _interpolated_ and _triple-quoted_ string with the syntax `s\"\"\"...\"\"\"`:\n* **Triple-quoted string:** `\"\"\"...\"\"\"`. Useful for embedding newlines, like we did inside `error`. (We'll see another benefit later.)\n* **String interpolation:** Invoked by putting `s` before the string, e.g., `s\"...\"` or `s\"\"\"...\"\"\"`. Lets us embed variable references and expressions, where the string conversion will be inserted automatically. For example: "
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "id" : "AFF78A0F505845BE88A3559B7958B24A"
    },
    "cell_type" : "code",
    "source" : "s\"\"\"Use braces for expressions: ${sc.version}.\nYou can omit the braces when just using a variable: $sc\nHowever, watch for ambiguities like ${sc}andextrastuff\"\"\"",
    "outputs" : [ {
      "name" : "stdout",
      "output_type" : "stream",
      "text" : "res13: String =\nUse braces for expressions: 1.6.2.\nYou can omit the braces when just using a variable: org.apache.spark.SparkContext@40800265\nHowever, watch for ambiguities like org.apache.spark.SparkContext@40800265andextrastuff\n"
    }, {
      "metadata" : { },
      "data" : {
        "text/html" : "Use braces for expressions: 1.6.2.\nYou can omit the braces when just using a variable: org.apache.spark.SparkContext@40800265\nHowever, watch for ambiguities like org.apache.spark.SparkContext@40800265andextrastuff"
      },
      "output_type" : "execute_result",
      "execution_count" : 8
    } ]
  }, {
    "metadata" : {
      "id" : "60FFAE1216ED45A480E3C68682B432DC"
    },
    "cell_type" : "markdown",
    "source" : "Another feature we're using for triple-quoted strings is the ability to strip the leading whitespace off each line. The `stripMargin` method removes all whitespace before and including the `|`. This lets you indent those lines for proper code formatting, but not have that whitespace remain in the string. In the following example, the resulting string has blank lines at the beginning and end. Note what happens with whitespace before `line2`:"
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "id" : "F85886E75E5A47C9861E3F65A8EB4267"
    },
    "cell_type" : "code",
    "source" : "s\"\"\"\n    |line 1\n    |  line 2\n    |\"\"\".stripMargin",
    "outputs" : [ {
      "name" : "stdout",
      "output_type" : "stream",
      "text" : "res15: String =\n\"\nline 1\n  line 2\n\"\n"
    }, {
      "metadata" : { },
      "data" : {
        "text/html" : "\nline 1\n  line 2\n"
      },
      "output_type" : "execute_result",
      "execution_count" : 9
    } ]
  }, {
    "metadata" : {
      "id" : "2D7671C27CAB4A678AB8F0DF595BF4F4"
    },
    "cell_type" : "markdown",
    "source" : "> **Note:**\n\n> Character \"literals\" are specified single quotes, '/', while strings use double quotes, \"/\"."
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "id" : "7E816DA2EE374A858D48A7CA8DB629C1"
    },
    "cell_type" : "code",
    "source" : "'/'",
    "outputs" : [ {
      "name" : "stdout",
      "output_type" : "stream",
      "text" : "res21: Char = /\n"
    }, {
      "metadata" : { },
      "data" : {
        "text/html" : "/"
      },
      "output_type" : "execute_result",
      "execution_count" : 12
    } ]
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "id" : "DE8F13B8E30D4EDF86972B678C67FF04"
    },
    "cell_type" : "code",
    "source" : "\"/\"",
    "outputs" : [ {
      "name" : "stdout",
      "output_type" : "stream",
      "text" : "res23: String = /\n"
    }, {
      "metadata" : { },
      "data" : {
        "text/html" : "/"
      },
      "output_type" : "execute_result",
      "execution_count" : 13
    } ]
  }, {
    "metadata" : {
      "id" : "5C941F03FED44CE090B662BFCDCE1491"
    },
    "cell_type" : "markdown",
    "source" : "### Download the Files\nNow let's define a method that works like the popularity \\*NIX [curl](http://linux.die.net/man/1/curl) utility. It's a bit long and you don't need to understand all the details, but we'll use it to download data we need for the notebook.\n\nThe whole body is one big [scala.util.Try](http://www.scala-lang.org/api/current/#scala.util.Try) expression. `Try` is a useful class for \"trying\" code that might throw an exception (more precisely, a [java.lang.Throwable](https://docs.oracle.com/javase/8/docs/api/java/lang/Throwable.html)). The long block, that is `Try {...}`, ends with `outFile`, a `File` instance. This is the result returned by the block, if everything succeeds. This `File` is wrapped in a `Try` subclass instance of type [scala.util.Success](http://www.scala-lang.org/api/current/scala/util/Success.html). However, if an exception is thrown in the block, then the exception is wrapped in an instance of another subclass, [scala.util.Failure](http://www.scala-lang.org/api/current/scala/util/Failure.html). (We'll discuss other advantages of `Try` and alternatives to it <a href=\"#TryOptionNull\">later</a>.)"
  }, {
    "metadata" : {
      "id" : "5D406BE17F12428081AD53D22E347148"
    },
    "cell_type" : "markdown",
    "source" : "Another construct we'll see for the first time is how to declare variables:\n* `val immutableValue = ...`: Once initialized, we can't assign a _different_ value to `immutableValue`.\n* `var mutableVariable = ...`: We can assign new values to `mutableVariable` as often as we want.\n\nIt's _highly recommended_ that you only use `vals` unless you have a good reason for needing mutability, which is a very common source of bugs!!\n\n> A `val immutableValue` could point to an instance that itself _is_ mutable, e.g., an [Array](http://www.scala-lang.org/api/current/#scala.Array). In this case, while we can't assign a new array to `immutableValue`, we can change elements within the array! Put another way, immutability isn't _transitive_."
  }, {
    "metadata" : {
      "id" : "5956F2A6A32C4782844AE7E53A982575"
    },
    "cell_type" : "markdown",
    "source" : "Most of the types used here are from Java's library (JDK). Because Scala compiles to JVM byte code, you can use any Java library you want from Scala:\n* [java.net.URL](https://docs.oracle.com/javase/8/docs/api/java/net/URL.html): Handles URL formatting and connections.\n* [java.io.File](https://docs.oracle.com/javase/8/docs/api/java/io/File.html): Working with files and directories.\n* [java.io.BufferedInputStream](https://docs.oracle.com/javase/8/docs/api/java/io/BufferedInputStream.html): Buffered input from an underlying stream.\n* [java.io.BufferedOutputStream](https://docs.oracle.com/javase/8/docs/api/java/io/BufferedOutputStream.html): Buffered output to an underlying stream.\n* [java.io.FileOutputStream](https://docs.oracle.com/javase/8/docs/api/java/io/FileOutputStream.html): Output to a file, specifically.\n\nAs before, we'll use comments to explain a few other new Scala constructs. "
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "id" : "1CD9CBDB4CE540AE8C0CACD1106377A6"
    },
    "cell_type" : "code",
    "source" : "// Import this utility for working with URLs. Unlike Java the semicolon ';' is not required.\nimport java.net.URL   \n\n// Use {...} to provide a list of things to import, when you don't want to import everything \n// in a package and you don't want to write a separate line for each type.\nimport java.io.{File, BufferedInputStream, BufferedOutputStream, FileOutputStream}\n\nimport scala.util.Try\n\n/**\n * Download a file at a URL and write it to a target directory.\n */\ndef curl(sourceURLString: String, targetDirectoryString: String): Try[File] = Try {\n\n    // The path separator on your platform: \"/\" on Linux and MacOS, \"\\\" on Windows.\n    val pathSeparator = File.separator\n\n    // Use the name of the remote file as the file name in the target directory.\n    // We split on the URL path elements using the separator, which is ALWAYS \"/\"\n    // on all platforms.\n    val sourceFileName = sourceURLString.split(\"/\").last  \n    val outFileName = targetDirectoryString + pathSeparator + sourceFileName\n\n    // Set up a connection and buffered input stream for the source file.\n    println(s\"Downloading $sourceURLString to $outFileName\")\n    val sourceURL = new URL(sourceURLString)\n    val connection = sourceURL.openConnection()\n    val in = new BufferedInputStream(connection.getInputStream())\n\n    // If here, the connection was successfully opened (i.e., no exceptions thrown).\n    // Now create the target directory (nothing happens if it already exists).\n    val targetDirectory = new File(targetDirectoryString)\n    targetDirectory.mkdirs()\n\n    // Setup the output file and a stream to write to it.\n    val outFile = new File(outFileName)\n    val out = new BufferedOutputStream(new FileOutputStream(outFile))\n    \n    // Create a buffer to hold the in-flight bytes.\n    val hundredK = 100*1024\n    val bytes = Array.fill[Byte](hundredK)(0)   // Create byte buffer, elements set to 0\n                                                // Array elements are _mutable_.\n    // Loop until we've read everything.\n    var loops = 0                               // A counter for progress feedback.\n    var count = in.read(bytes, 0, hundredK)     // Read up to \"hundredK\" bytes at a time.\n    while (count != -1) {                       // Haven't hit the end of input yet?\n        if (loops % 10 == 0) print(\".\")         // Print occasional feedback.\n        loops += 1                              // increment the counter.\n        out.write(bytes, 0, count)              // Write to the new file.\n        count = in.read(bytes, 0, hundredK)     // Read the next chunk and loop...\n    }\n    println(\"\\nFinished!\")\n    in.close()                                  // Clean up! Close file & stream handles\n    out.flush()\n    out.close()\n    outFile                                     // Returned file (if we got this far)\n}",
    "outputs" : [ {
      "name" : "stdout",
      "output_type" : "stream",
      "text" : "import java.net.URL\nimport java.io.{File, BufferedInputStream, BufferedOutputStream, FileOutputStream}\nimport scala.util.Try\ncurl: (sourceURLString: String, targetDirectoryString: String)scala.util.Try[java.io.File]\n"
    }, {
      "metadata" : { },
      "data" : {
        "text/html" : ""
      },
      "output_type" : "execute_result",
      "execution_count" : 12
    } ]
  }, {
    "metadata" : {
      "id" : "2C4EA916B7974EAE8863CDB8D78251B7"
    },
    "cell_type" : "markdown",
    "source" : "Okay, before we actually use `curl`, let's create the target directory. (This is also done in `curl`, but we're using the success or failure for other purposes here.) \n\nScala's `if` construct is actually an expression (in Java they are _statements_). The `if` expression will return `true` or `false` and assign it to `success`, which we'll use in a moment."
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "id" : "2694A3E4B4FF44F683842A9AB7742C89"
    },
    "cell_type" : "code",
    "source" : "// The target directory, which we'll now create, if necessary.\nval shakespeare = new File(\"data/shakespeare\")",
    "outputs" : [ {
      "name" : "stdout",
      "output_type" : "stream",
      "text" : "shakespeare: java.io.File = data/shakespeare\n"
    }, {
      "metadata" : { },
      "data" : {
        "text/html" : ""
      },
      "output_type" : "execute_result",
      "execution_count" : 13
    } ]
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "id" : "CFADB7E042BC4F59837EA8CBCE16CDB2"
    },
    "cell_type" : "code",
    "source" : "val success = if (shakespeare.exists == false) {   // doesn't exist already?\n    if (shakespeare.mkdirs() == false) {           // did the attempt fail??\n        error(s\"Failed to create directory path: $shakespeare\")  // ignore returned string\n        false\n    } else {                                       // successful\n        info(s\"Created $shakespeare\")\n        true\n    }\n} else {\n    info(s\"$shakespeare already exists\")\n    true\n}\nprintln(\"success = \" + success)",
    "outputs" : [ {
      "name" : "stdout",
      "output_type" : "stream",
      "text" : "Created data/shakespeare\nsuccess = true\nsuccess: Boolean = true\n"
    }, {
      "metadata" : { },
      "data" : {
        "text/html" : ""
      },
      "output_type" : "execute_result",
      "execution_count" : 14
    } ]
  }, {
    "metadata" : {
      "id" : "015D2C9460EC4C619EEDE8AF53019887"
    },
    "cell_type" : "markdown",
    "source" : "If we successfully created the output directory (or it already existed), let's download a handful of files, each with one play of Shakespeare, from [http://www.cs.usyd.edu.au/~matty/Shakespeare/](http://www.cs.usyd.edu.au/~matty/Shakespeare/)."
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "id" : "FD299F503F6E45128FB1243B1E4C5025"
    },
    "cell_type" : "code",
    "source" : "val pathSeparator = File.separator\nval targetDirName = shakespeare.toString\nval urlRoot = \"http://www.cs.usyd.edu.au/~matty/Shakespeare/texts/comedies/\"\nval plays = Seq(\n    \"tamingoftheshrew\", \"comedyoferrors\", \"loveslabourslost\", \"midsummersnightsdream\",\n    \"merrywivesofwindsor\", \"muchadoaboutnothing\", \"asyoulikeit\", \"twelfthnight\")\n\nif (success) {\n    println(s\"Downloading plays from $urlRoot.\")\n    for {\n        play <- plays\n        playFile = new File(targetDirName + pathSeparator + play)\n        if (playFile.exists == false)\n        tryFile = curl(urlRoot + play, targetDirName)\n    } {\n        // If successful, then `foreach` extracts the `File` so we can use it.\n        tryFile.foreach(file => info(s\"Downloaded $play and wrote $file\"))\n        // If unsuccessful, `recover` extracts the `Throwable`...\n        tryFile.recover{ case throwable => error(s\"Failed to download $play. $throwable\") }\n    }\n    println(\"Finished!\")\n}",
    "outputs" : [ {
      "name" : "stdout",
      "output_type" : "stream",
      "text" : "Downloading plays from http://www.cs.usyd.edu.au/~matty/Shakespeare/texts/comedies/.\nDownloading http://www.cs.usyd.edu.au/~matty/Shakespeare/texts/comedies/tamingoftheshrew to data/shakespeare/tamingoftheshrew\n.......\nFinished!\nDownloading http://www.cs.usyd.edu.au/~matty/Shakespeare/texts/comedies/comedyoferrors to data/shakespeare/comedyoferrors\n....\nFinished!\nDownloading http://www.cs.usyd.edu.au/~matty/Shakespeare/texts/comedies/loveslabourslost to data/shakespeare/loveslabourslost\n....\nFinished!\nDownloading http://www.cs.usyd.edu.au/~matty/Shakespeare/texts/comedies/midsummersnightsdream to data/shakespeare/midsummersnightsdream\n....\nFinished!\nDownloading http://www.cs.usyd.edu.au/~matty/Shakespeare/texts/comedies/merrywivesofwindsor to data/shakespeare/merrywivesofwindsor\n....\nFinished!\nDownloading http://www.cs.usyd.edu.au/~matty/Shakespeare/texts/comedies/muchadoaboutnothing to data/shakespeare/muchadoaboutnothing\n....\nFinished!\nDownloading http://www.cs.usyd.edu.au/~matty/Shakespeare/texts/comedies/asyoulikeit to data/shakespeare/asyoulikeit\n.....\nFinished!\nDownloading http://www.cs.usyd.edu.au/~matty/Shakespeare/texts/comedies/twelfthnight to data/shakespeare/twelfthnight\n......\nFinished!\nDownloaded tamingoftheshrew and wrote data/shakespeare/tamingoftheshrew\nDownloaded comedyoferrors and wrote data/shakespeare/comedyoferrors\nDownloaded loveslabourslost and wrote data/shakespeare/loveslabourslost\nDownloaded midsummersnightsdream and wrote data/shakespeare/midsummersnightsdream\nDownloaded merrywivesofwindsor and wrote data/shakespeare/merrywivesofwindsor\nDownloaded muchadoaboutnothing and wrote data/shakespeare/muchadoaboutnothing\nDownloaded asyoulikeit and wrote data/shakespeare/asyoulikeit\nDownloaded twelfthnight and wrote data/shakespeare/twelfthnight\nFinished!\npathSeparator: String = /\ntargetDirName: String = data/shakespeare\nurlRoot: String = http://www.cs.usyd.edu.au/~matty/Shakespeare/texts/comedies/\nplays: Seq[String] = List(tamingoftheshrew, comedyoferrors, loveslabourslost, midsummersnightsdream, merrywivesofwindsor, muchadoaboutnothing, asyoulikeit, twelfthnight)\n"
    }, {
      "metadata" : { },
      "data" : {
        "text/html" : ""
      },
      "output_type" : "execute_result",
      "execution_count" : 15
    } ]
  }, {
    "metadata" : {
      "id" : "8D9C6981C7CE4E79BAC96837D15A4EC8"
    },
    "cell_type" : "markdown",
    "source" : "I'm using a so-called `for` _comprehension_. They are _expressions_, not _statements_ like Java's `for` loops (although we ignore the return value here). \n\n`for {play <- plays; ...} { block }` iterates through a collection, `plays`, and assigns each one to the `play` variable. Note you can use parentheses `(...)` instead of braces `{...}` when you have a single expression on the same line, e.g., \n\n```scala\nfor (play <- plays) println(play)\n```\n\nI also omitted the final `{...}` around the single statement `println(play)`.\n\nAfter assigning to `play`, subsequent steps in the comprehension use it. First, a [java.io.File](https://docs.oracle.com/javase/8/docs/api/java/io/File.html) instance, `playFile`, is created. Then, `playFile` is used to evaluate a conditional - does the file already exist (i.e., have we already downloaded this file)?\n\nIf the file already exists, the conditional returns `false`, which short-circuits the loop and goes to the next `play` in the list. If the file doesn't exit, the final expression uses `curl` to download it. "
  }, {
    "metadata" : {
      "id" : "96AC4A42AC9F444195CB2AE333DAE3D1"
    },
    "cell_type" : "markdown",
    "source" : "Recall that `curl` returns a `Try[File]`, which is assigned to `tryFile`. A final block is needed in a `for` comprehension. Inside the braces `{...}` I check `tryFile` for whether or not it succeeded and print a message accordingly:\n\n* `result.foreach` actually does nothing if a `Failure` is returned, but if a `Success` is returned, calling `foreach` extracts the `File` inside the `Success` and I use it for an information message.\n* `result.recover` does nothing if a `Success` is returned, but if a `Failure` is returned, the `Throwable` is extracted and I use it to print an error message. \n\n> For both `result.foreach` and `result.recover`, I pass an _anonymous_ (unnamed) _function_ to them to do the processing I want. So here are the first examples of _functions_, as opposed to _methods_. However, I'll wait until later in this notebook to explain the two kinds of function syntax used here."
  }, {
    "metadata" : {
      "id" : "BEDF4C824D3E4CA1BA4E0EC1C9D9A71B"
    },
    "cell_type" : "markdown",
    "source" : "This use of a `for` comprehension is sometimes called a \"for loop\" because it returns nothing; it just prints messages. For completeness, here's another example, where I construct a new collection (of strings) using a `for` comprehension. I'll use it as a sanity check to verify the downloads were successful."
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "presentation" : {
        "tabs_state" : "{\n  \"tab_id\": \"#tab1917929261-0\"\n}",
        "pivot_chart_state" : "{\n  \"hiddenAttributes\": [],\n  \"menuLimit\": 200,\n  \"cols\": [],\n  \"rows\": [],\n  \"vals\": [],\n  \"exclusions\": {},\n  \"inclusions\": {},\n  \"unusedAttrsVertical\": 85,\n  \"autoSortUnusedAttrs\": false,\n  \"inclusionsInfo\": {},\n  \"aggregatorName\": \"Count\",\n  \"rendererName\": \"Table\"\n}"
      },
      "id" : "6AEF3C277BC64C43A9FF1A778EB7E183"
    },
    "cell_type" : "code",
    "source" : "val list = for {\n    play <- plays \n    playFileString = targetDirName + pathSeparator + play\n    playFile = new File(playFileString)\n} yield {\n    val successString = if (playFile.exists) \"Success!\" else \"NOT FOUND!!\"\n    \"%-40s\\t%s\".format(playFileString, successString)\n}\n\nlist   // Let's see the type of the new collection.",
    "outputs" : [ {
      "name" : "stdout",
      "output_type" : "stream",
      "text" : "list: Seq[String] = List(data/shakespeare/tamingoftheshrew       \tSuccess!, data/shakespeare/comedyoferrors         \tSuccess!, data/shakespeare/loveslabourslost       \tSuccess!, data/shakespeare/midsummersnightsdream  \tSuccess!, data/shakespeare/merrywivesofwindsor    \tSuccess!, data/shakespeare/muchadoaboutnothing    \tSuccess!, data/shakespeare/asyoulikeit            \tSuccess!, data/shakespeare/twelfthnight           \tSuccess!)\nres26: Seq[String] = List(data/shakespeare/tamingoftheshrew       \tSuccess!, data/shakespeare/comedyoferrors         \tSuccess!, data/shakespeare/loveslabourslost       \tSuccess!, data/shakespeare/midsummersnightsdream  \tSuccess!, data/shakespeare/merrywivesofwindsor    \tSuccess!, data/shakespeare/muchadoaboutnothing    \tSuccess!, data/shakespeare/asyoulikeit    ..."
    }, {
      "metadata" : { },
      "data" : {
        "text/html" : "<div>\n      <script data-this=\"{&quot;dataId&quot;:&quot;anonf72c8fa2b56ba36a2f139502baab6c4c&quot;,&quot;dataInit&quot;:[{&quot;string value&quot;:&quot;data/shakespeare/tamingoftheshrew       \\tSuccess!&quot;},{&quot;string value&quot;:&quot;data/shakespeare/comedyoferrors         \\tSuccess!&quot;},{&quot;string value&quot;:&quot;data/shakespeare/loveslabourslost       \\tSuccess!&quot;},{&quot;string value&quot;:&quot;data/shakespeare/midsummersnightsdream  \\tSuccess!&quot;},{&quot;string value&quot;:&quot;data/shakespeare/merrywivesofwindsor    \\tSuccess!&quot;},{&quot;string value&quot;:&quot;data/shakespeare/muchadoaboutnothing    \\tSuccess!&quot;},{&quot;string value&quot;:&quot;data/shakespeare/asyoulikeit            \\tSuccess!&quot;},{&quot;string value&quot;:&quot;data/shakespeare/twelfthnight           \\tSuccess!&quot;}],&quot;genId&quot;:&quot;1917929261&quot;}\" type=\"text/x-scoped-javascript\">/*<![CDATA[*/req(['../javascripts/notebook/playground','../javascripts/notebook/magic/tabs'], \n      function(playground, _magictabs) {\n        // data ==> data-this (in observable.js's scopedEval) ==> this in JS => { dataId, dataInit, ... }\n        // this ==> scope (in observable.js's scopedEval) ==> this.parentElement ==> div.container below (toHtml)\n\n        playground.call(data,\n                        this\n                        ,\n                        {\n    \"f\": _magictabs,\n    \"o\": {}\n  }\n  \n                        \n                        \n                      );\n      }\n    );/*]]>*/</script>\n    <div>\n        <div>\n          <ul class=\"nav nav-tabs\" id=\"ul1917929261\"><li>\n                <a href=\"#tab1917929261-0\"><i class=\"fa fa-table\"/></a>\n              </li><li>\n                <a href=\"#tab1917929261-1\"><i class=\"fa fa-cubes\"/></a>\n              </li></ul>\n\n          <div class=\"tab-content\" id=\"tab1917929261\"><div class=\"tab-pane\" id=\"tab1917929261-0\">\n              <div>\n      <script data-this=\"{&quot;dataId&quot;:&quot;anon4365c45aaab35160c798f3cf11dd27a9&quot;,&quot;dataInit&quot;:[{&quot;string value&quot;:&quot;data/shakespeare/tamingoftheshrew       \\tSuccess!&quot;},{&quot;string value&quot;:&quot;data/shakespeare/comedyoferrors         \\tSuccess!&quot;},{&quot;string value&quot;:&quot;data/shakespeare/loveslabourslost       \\tSuccess!&quot;},{&quot;string value&quot;:&quot;data/shakespeare/midsummersnightsdream  \\tSuccess!&quot;},{&quot;string value&quot;:&quot;data/shakespeare/merrywivesofwindsor    \\tSuccess!&quot;},{&quot;string value&quot;:&quot;data/shakespeare/muchadoaboutnothing    \\tSuccess!&quot;},{&quot;string value&quot;:&quot;data/shakespeare/asyoulikeit            \\tSuccess!&quot;},{&quot;string value&quot;:&quot;data/shakespeare/twelfthnight           \\tSuccess!&quot;}],&quot;genId&quot;:&quot;2030256961&quot;}\" type=\"text/x-scoped-javascript\">/*<![CDATA[*/req(['../javascripts/notebook/playground','../javascripts/notebook/magic/tableChart'], \n      function(playground, _magictableChart) {\n        // data ==> data-this (in observable.js's scopedEval) ==> this in JS => { dataId, dataInit, ... }\n        // this ==> scope (in observable.js's scopedEval) ==> this.parentElement ==> div.container below (toHtml)\n\n        playground.call(data,\n                        this\n                        ,\n                        {\n    \"f\": _magictableChart,\n    \"o\": {\"headers\":[\"string value\"],\"width\":600,\"height\":400}\n  }\n  \n                        \n                        \n                      );\n      }\n    );/*]]>*/</script>\n    <div>\n        <p data-bind=\"text: value\"><script data-this=\"{&quot;valueId&quot;:&quot;anon1cebbed95d0244814b7f029549372697&quot;}\" type=\"text/x-scoped-javascript\">/*<![CDATA[*/\nreq(\n['observable', 'knockout'],\nfunction (O, ko) {\n  ko.applyBindings({\n      value: O.makeObservable(valueId)\n    },\n    this\n  );\n});\n        /*]]>*/</script></p> <span style=\"color:red\"><p data-bind=\"text: value\"><script data-this=\"{&quot;valueId&quot;:&quot;anon22b69fa2ce3f4ea2a12a99d012acef3d&quot;}\" type=\"text/x-scoped-javascript\">/*<![CDATA[*/\nreq(\n['observable', 'knockout'],\nfunction (O, ko) {\n  ko.applyBindings({\n      value: O.makeObservable(valueId)\n    },\n    this\n  );\n});\n        /*]]>*/</script></p></span>\n        <div>\n        </div>\n      </div></div>\n              </div><div class=\"tab-pane\" id=\"tab1917929261-1\">\n              <div>\n      <script data-this=\"{&quot;dataId&quot;:&quot;anon5815c6dbaa3c1f9958a7dd658e649c77&quot;,&quot;dataInit&quot;:[{&quot;string value&quot;:&quot;data/shakespeare/tamingoftheshrew       \\tSuccess!&quot;},{&quot;string value&quot;:&quot;data/shakespeare/comedyoferrors         \\tSuccess!&quot;},{&quot;string value&quot;:&quot;data/shakespeare/loveslabourslost       \\tSuccess!&quot;},{&quot;string value&quot;:&quot;data/shakespeare/midsummersnightsdream  \\tSuccess!&quot;},{&quot;string value&quot;:&quot;data/shakespeare/merrywivesofwindsor    \\tSuccess!&quot;},{&quot;string value&quot;:&quot;data/shakespeare/muchadoaboutnothing    \\tSuccess!&quot;},{&quot;string value&quot;:&quot;data/shakespeare/asyoulikeit            \\tSuccess!&quot;},{&quot;string value&quot;:&quot;data/shakespeare/twelfthnight           \\tSuccess!&quot;}],&quot;genId&quot;:&quot;1941138907&quot;}\" type=\"text/x-scoped-javascript\">/*<![CDATA[*/req(['../javascripts/notebook/playground','../javascripts/notebook/magic/pivotChart'], \n      function(playground, _magicpivotChart) {\n        // data ==> data-this (in observable.js's scopedEval) ==> this in JS => { dataId, dataInit, ... }\n        // this ==> scope (in observable.js's scopedEval) ==> this.parentElement ==> div.container below (toHtml)\n\n        playground.call(data,\n                        this\n                        ,\n                        {\n    \"f\": _magicpivotChart,\n    \"o\": {\"width\":600,\"height\":400,\"derivedAttributes\":{},\"extraOptions\":{}}\n  }\n  \n                        \n                        \n                      );\n      }\n    );/*]]>*/</script>\n    <div>\n        <p data-bind=\"text: value\"><script data-this=\"{&quot;valueId&quot;:&quot;anond2f70b722fca5b0133a6a7b1c73a145b&quot;}\" type=\"text/x-scoped-javascript\">/*<![CDATA[*/\nreq(\n['observable', 'knockout'],\nfunction (O, ko) {\n  ko.applyBindings({\n      value: O.makeObservable(valueId)\n    },\n    this\n  );\n});\n        /*]]>*/</script></p> <span style=\"color:red\"><p data-bind=\"text: value\"><script data-this=\"{&quot;valueId&quot;:&quot;anon5f770decb7457e17d6f0e56545aa8203&quot;}\" type=\"text/x-scoped-javascript\">/*<![CDATA[*/\nreq(\n['observable', 'knockout'],\nfunction (O, ko) {\n  ko.applyBindings({\n      value: O.makeObservable(valueId)\n    },\n    this\n  );\n});\n        /*]]>*/</script></p></span>\n        <div>\n        </div>\n      </div></div>\n              </div></div>\n        </div>\n      </div></div>"
      },
      "output_type" : "execute_result",
      "execution_count" : 16
    } ]
  }, {
    "metadata" : {
      "id" : "E4EFBDFC37CA464B8C304B529013E4B1"
    },
    "cell_type" : "markdown",
    "source" : "The `yield` keyword tells Scala that I want to construct a new collection, using the expression that follows to construct elements, formatted strings. I use another way to format a string, with C-style \"printf\" formatting."
  }, {
    "metadata" : {
      "id" : "3294471AEA464DED856AAD4DEC34DDB3"
    },
    "cell_type" : "markdown",
    "source" : "Now we'll print the strings. The idiom `collection.foreach(println)` is handy for looping over the elements and printing them, one per line."
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "id" : "9B3811BAC9194A7AA30DDB65678F075A"
    },
    "cell_type" : "code",
    "source" : "println(s\"There should be ${plays.size} files:\")\nlist.foreach(println)",
    "outputs" : [ {
      "name" : "stdout",
      "output_type" : "stream",
      "text" : "There should be 8 files:\ndata/shakespeare/tamingoftheshrew       \tSuccess!\ndata/shakespeare/comedyoferrors         \tSuccess!\ndata/shakespeare/loveslabourslost       \tSuccess!\ndata/shakespeare/midsummersnightsdream  \tSuccess!\ndata/shakespeare/merrywivesofwindsor    \tSuccess!\ndata/shakespeare/muchadoaboutnothing    \tSuccess!\ndata/shakespeare/asyoulikeit            \tSuccess!\ndata/shakespeare/twelfthnight           \tSuccess!\n"
    }, {
      "metadata" : { },
      "data" : {
        "text/html" : ""
      },
      "output_type" : "execute_result",
      "execution_count" : 17
    } ]
  }, {
    "metadata" : {
      "id" : "57F9A2BADC9F4AF386B7E2D11DE24EDC"
    },
    "cell_type" : "markdown",
    "source" : "**Exercise:** Here's the `for` comprehension again in the following cell, plus the statement that prints it. Recall we used a conditional expression in our first `for` comprehension. Try adding a conditional here that only prints the plays with \"of\" (or some other word) in the title. Also try printing only the plays that don't have \"of\"."
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "id" : "FCAAADD398B0442AAFA20A6266C2EEFB"
    },
    "cell_type" : "code",
    "source" : "val list2 = for {\n    play <- plays \n    playFileString = targetDirName + pathSeparator + play\n    playFile = new File(playFileString)\n} yield {\n    val successString = if (playFile.exists) \"Success!\" else \"NOT FOUND!!\"\n    \"%-40s\\t%s\".format(playFileString, successString)\n}\nlist2.foreach(println)",
    "outputs" : [ {
      "name" : "stdout",
      "output_type" : "stream",
      "text" : "data/shakespeare/tamingoftheshrew       \tSuccess!\ndata/shakespeare/comedyoferrors         \tSuccess!\ndata/shakespeare/loveslabourslost       \tSuccess!\ndata/shakespeare/midsummersnightsdream  \tSuccess!\ndata/shakespeare/merrywivesofwindsor    \tSuccess!\ndata/shakespeare/muchadoaboutnothing    \tSuccess!\ndata/shakespeare/asyoulikeit            \tSuccess!\ndata/shakespeare/twelfthnight           \tSuccess!\nlist2: Seq[String] = List(data/shakespeare/tamingoftheshrew       \tSuccess!, data/shakespeare/comedyoferrors         \tSuccess!, data/shakespeare/loveslabourslost       \tSuccess!, data/shakespeare/midsummersnightsdream  \tSuccess!, data/shakespeare/merrywivesofwindsor    \tSuccess!, data/shakespeare/muchadoaboutnothing    \tSuccess!, data/shakespeare/asyoulikeit            \tSuccess!, data/shakespeare/twelfthnight           \tSuccess!)\n"
    }, {
      "metadata" : { },
      "data" : {
        "text/html" : ""
      },
      "output_type" : "execute_result",
      "execution_count" : 18
    } ]
  }, {
    "metadata" : {
      "id" : "EA38A54959954056A26AFB2136540AD4"
    },
    "cell_type" : "markdown",
    "source" : "## Inverted Index - When You're Tired of Counting Words...\n\nWhew! We've learned a lot of Scala already while doing typical data science chores (i.e., fetching data). \n\nNow let's implement a real algorithm using Spark, _Inverted Index_. You'll want this when you create your next \"Google killer\". It takes in a corpus of documents (e.g., web pages), tokenizes the words, and outputs for each word a list of the documents that contain it, along with the corresponding counts. \n\nThis is a slightly more interesting algorithm than _Word Count_, the classic \"hello world\" program everyone implements when they learn Spark.\n\nThe term _inverted_ here means we start with the words as part of the input _values_, while the _keys_ are the document identifiers, and we'll switch to using the words as keys and the document identifiers as values."
  }, {
    "metadata" : {
      "id" : "D7F7A6A97DE14FA18131C707E4599D8A"
    },
    "cell_type" : "markdown",
    "source" : "Here's our first version, all at once. This is _one, long expression_. Note the periods `.` at the end of the subexpressions."
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "id" : "279CFDA0E697461A8109AF880AF3FF10"
    },
    "cell_type" : "code",
    "source" : "val iiFirstPass1 = sc.wholeTextFiles(shakespeare.toString).\n    flatMap { location_contents_tuple2 => \n        val words = location_contents_tuple2._2.split(\"\"\"\\W+\"\"\")\n        val fileName = location_contents_tuple2._1.split(pathSeparator).last\n        words.map(word => ((word, fileName), 1))\n    }.\n    reduceByKey((count1, count2) => count1 + count2).\n    map { word_file_count_tup3 => \n        (word_file_count_tup3._1._1, (word_file_count_tup3._1._2, word_file_count_tup3._2)) \n    }.\n    groupByKey.\n    sortByKey(ascending = true).\n    mapValues { iterable => \n        val vect = iterable.toVector.sortBy { file_count_tup2 => \n            (-file_count_tup2._2, file_count_tup2._1)\n        }\n        vect.mkString(\",\")\n    }",
    "outputs" : [ {
      "name" : "stdout",
      "output_type" : "stream",
      "text" : "iiFirstPass1: org.apache.spark.rdd.RDD[(String, String)] = MapPartitionsRDD[9] at mapValues at <console>:72\n"
    }, {
      "metadata" : { },
      "data" : {
        "text/html" : ""
      },
      "output_type" : "execute_result",
      "execution_count" : 19
    } ]
  }, {
    "metadata" : {
      "id" : "5C58024E869A433188F2002554FD0DD8"
    },
    "cell_type" : "markdown",
    "source" : "Now I'll break it down into steps, assigning each step to a variable. This extra verbosity let's us see what Scala infers for the type returned by each expression. \n\nThis is one of the nice features of Scala. We don't have to put in the type information ourselves, most of the time, like we would have to do for Java code. Instead, we let the compiler give us feedback about what we just created. This is especially useful when you're learning a new API, like Spark's."
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "id" : "5C14F35215B645AF8E1114F13E06BE84"
    },
    "cell_type" : "code",
    "source" : "val fileContents = sc.wholeTextFiles(shakespeare.toString)\nfileContents   // force the notebook to print the type.",
    "outputs" : [ {
      "name" : "stdout",
      "output_type" : "stream",
      "text" : "fileContents: org.apache.spark.rdd.RDD[(String, String)] = data/shakespeare MapPartitionsRDD[11] at wholeTextFiles at <console>:58\nres33: org.apache.spark.rdd.RDD[(String, String)] = data/shakespeare MapPartitionsRDD[11] at wholeTextFiles at <console>:58\n"
    }, {
      "metadata" : { },
      "data" : {
        "text/html" : "data/shakespeare MapPartitionsRDD[11] at wholeTextFiles at &lt;console&gt;:58"
      },
      "output_type" : "execute_result",
      "execution_count" : 20
    } ]
  }, {
    "metadata" : {
      "id" : "3DE80FDA9C8947938A39BDB23B6A7E59"
    },
    "cell_type" : "markdown",
    "source" : "The second line, with `fileContents` by itself, is there so the notebook will show us its type information. (Try to remove it and re-evaluate the cell. Nothing is printed.). \n\nThe output is telling us that `fileContents` has the type [RDD[(String,String)]](http://spark.apache.org/docs/latest/api/scala/index.html#org.apache.spark.rdd.RDD), but the instance is actually a `MapPartitionsRDD`, which is a \"private\" implementation subclass of `RDD`. A named followed by square brackets, `[...]`, means that `RDD[...]` requires one or more type parameters in the brackets. In this case, a single type parameter, which represents the type of records being held. \n\nThe single type parameter is given by `(String,String)`, which is a convenient shorthand for [Tuple2[String,String]](http://www.scala-lang.org/api/current/index.html#scala.Tuple2). That is, we have two-element _tuples_ as records, where the first element is for a file's fully-qualified path and the second element is the contents of that file. This is what `SparkContext.wholeTextFiles` returns for us. We'll use the path to remember where we found words, while the contents contains the words themselves (of course).\n\nTo recap, the following two types are equivalent:\n* `RDD[(String,String)]`: Note `[(...)]`\n* `RDD[Tuple2[String,String]]` Note nested brackets `[...[...]]`, not `[(...)]`"
  }, {
    "metadata" : {
      "id" : "E7013006BEBB49818F71394C6006B8E6"
    },
    "cell_type" : "markdown",
    "source" : "We'll see shortly that you can also write _instances_ of [Tuple2[T1,T2]](http://www.scala-lang.org/api/current/index.html#scala.Tuple2) with the same syntax, e.g., `(\"foo\", 101)`, for a `(String,Int)` tuple, and similarly for _higher-arity_ tuples (up to 22 elements...), e.g., `(\"foo\", 101, 3.14159, (\"bar\", 202L))`. Run the next cell to see the type signature for this last tuple."
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "id" : "348ECFFC072E498A90A069E8FBD896C6"
    },
    "cell_type" : "code",
    "source" : "(\"foo\", 101, 3.14159, (\"bar\", 202L))",
    "outputs" : [ {
      "name" : "stdout",
      "output_type" : "stream",
      "text" : "res35: (String, Int, Double, (String, Long)) = (foo,101,3.14159,(bar,202))\n"
    }, {
      "metadata" : { },
      "data" : {
        "text/html" : "(foo,101,3.14159,(bar,202))"
      },
      "output_type" : "execute_result",
      "execution_count" : 21
    } ]
  }, {
    "metadata" : {
      "id" : "D3DDA1765CFF488C9C09518D2B7A6709"
    },
    "cell_type" : "markdown",
    "source" : "Do you understand it? Do you see that it's a four-element tuple and not a five-element tuple? This is because the `(\"bar\", 202L)` is a nested tuple. It's the fourth element of the outer tuple."
  }, {
    "metadata" : {
      "id" : "560F2DC1EAAD46F28CDDBB2F5BE877ED"
    },
    "cell_type" : "markdown",
    "source" : "**Exercise:** Try creating some more tuples with elements of different types. Use the next cell."
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "id" : "E9EA7CFFCEE24419B028DE88C7AE70A3"
    },
    "cell_type" : "code",
    "source" : "(1,2)",
    "outputs" : [ {
      "name" : "stdout",
      "output_type" : "stream",
      "text" : "res37: (Int, Int) = (1,2)\n"
    }, {
      "metadata" : { },
      "data" : {
        "text/html" : "(1,2)"
      },
      "output_type" : "execute_result",
      "execution_count" : 22
    } ]
  }, {
    "metadata" : {
      "id" : "DC32974A3B8D40F08D6F1717F6C5B6D2"
    },
    "cell_type" : "markdown",
    "source" : "How many `fileContents` records do we have? Not many. It should be the same number as the number of files we downloaded above."
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "id" : "36EF21C8E62149838CF404DC4BC1E803"
    },
    "cell_type" : "code",
    "source" : "fileContents.count",
    "outputs" : [ {
      "name" : "stdout",
      "output_type" : "stream",
      "text" : "res39: Long = 8\n"
    }, {
      "metadata" : { },
      "data" : {
        "text/html" : "8"
      },
      "output_type" : "execute_result",
      "execution_count" : 23
    } ]
  }, {
    "metadata" : {
      "id" : "6A7FE239825A4DAE86368FAF6E09A142"
    },
    "cell_type" : "markdown",
    "source" : "Now for our next step in the calculation. First, \"tokenize\" the contents into words by splitting on non-alphanumeric characters, meaning all runs of whitespace (including the newlines), punctuation, etc.\n\nNext, the fully-qualified path is verbose and the same prefix is repeated for all the files, so let's extract just the last element of it, the unique file name.\n\nThen form new tuples with the words and file names.\n\n> **Note:** This \"tokenization\" approach is very crude. It improperly handles contractions, like `it's` and hyphenated words like `world-changing`. When you kill Google, be sure to use a real _natural language processing_ (NLP) tokenization technique."
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "id" : "E072D355D0FF43B58F08848DEAC6109C"
    },
    "cell_type" : "code",
    "source" : "val wordFileNameOnes = fileContents.flatMap { location_contents_tuple2 => \n    val words = location_contents_tuple2._2.split(\"\"\"\\W+\"\"\")\n    val fileName = location_contents_tuple2._1.split(pathSeparator).last\n    words.map(word => ((word, fileName), 1))\n}\nwordFileNameOnes",
    "outputs" : [ {
      "name" : "stdout",
      "output_type" : "stream",
      "text" : "wordFileNameOnes: org.apache.spark.rdd.RDD[((String, String), Int)] = MapPartitionsRDD[12] at flatMap at <console>:62\nres41: org.apache.spark.rdd.RDD[((String, String), Int)] = MapPartitionsRDD[12] at flatMap at <console>:62\n"
    }, {
      "metadata" : { },
      "data" : {
        "text/html" : "MapPartitionsRDD[12] at flatMap at &lt;console&gt;:62"
      },
      "output_type" : "execute_result",
      "execution_count" : 24
    } ]
  }, {
    "metadata" : {
      "id" : "2E98B66DEE2140378F9FA7377ADF1A9A"
    },
    "cell_type" : "markdown",
    "source" : "I find this hard to read and shortly I'll show you a much more elegant, alternative syntax.\n\nLet's understand the difference between `map` and `flatMap`. If I called `fileContents.map`, it would return exactly _one_ new record for each record in _fileContents_. What I actually want instead are new records for each word-fileName combination, a significantly larger number (but the data in each record will be much smaller). \n\nUsing `fileContents.flatMap` gives me what I want. Instead of returning one output record for each input record, a `flatMap` returns a _collection_ of new records, zero or more, for _each_ input record. These collections are then _flattened_ into one big collection, another `RDD` in this case."
  }, {
    "metadata" : {
      "id" : "FB33105E2CF641E7AE3BB637A5A0AA82"
    },
    "cell_type" : "markdown",
    "source" : "What should `flatMap` actually do with each record? I pass a _function_ to define what to do. I'm using an unnamed or _anonymous_ function. The syntax is `argument_list => body`:\n\n```scala\nlocation_contents_tuple2 => \n    val words = ...\n    ...\n}\n```\n\nI have a single argument, the record, which I named `location_contents_tuple2`, a verbose way to say that it's a two-element tuple with an input file's location and contents. I don't require a type parameter after `location_contents_tuple2`, because it's inferred by Scala. The `=>` \"arrow\" separates the argument list from the body, which appears on the next few lines.\n\nIf the function has more than one argument or type _annotations_ are added (e.g., `: (String,String)`), then I would need parentheses, e.g.,\n\n```scala\n(location_contents_tuple2: (String,String)) => ...\n(arg1, arg2, arg3) => ...\n```"
  }, {
    "metadata" : {
      "id" : "1053B25F426A40558F2F51C474EC8998"
    },
    "cell_type" : "markdown",
    "source" : "Wait, I said we're passing a function as an argument to `flatMap`. If so, why am I using braces `{...}` around this function instead of parentheses `(...)` like you would normally expect when passing arguments to a method like `flatMap`? \n\nIt's because Scala lets us use braces instead of parentheses so we have the familiar block-like syntax `{...}` we know and love for `if` and `for` expressions. I could use either braces or parentheses here. The convention in the Scala community for a multi-line anonymous function is to use braces and to use parentheses for a single expression when it fits on the same line. (There is one exception where braces are required, which I'll discuss later.)"
  }, {
    "metadata" : {
      "id" : "E6C1137A823349E082F92E38C1F3FACF"
    },
    "cell_type" : "markdown",
    "source" : "Now, for each `location_contents_tuple2`, I access the _first_ element using the `_1` method and the _second_ element using `_2`.\n\nThe `contents` is in the second element. I split it by calling Java's `String.split` method, which takes a _regular expression_ string. Here I specify a regular expression for one or more, non-alphanumeric characters. `String.split` returns an `Array[String]` of the words. \n\n```scala\n    val words = location_contents_tuple2._2.split(\"\"\"\\W+\"\"\")\n```\n\nFor the first tuple element, I extract the file name at the end of the location path. This isn't necessary, but it makes the output more readable if I remove the long, common prefix from the path. \n\n```scala\n    val fileName = location_contents_tuple2._1.split(pathSeparator).last\n```"
  }, {
    "metadata" : {
      "id" : "CEF8F60B111D4EE8B4F08C0DAF4E3701"
    },
    "cell_type" : "markdown",
    "source" : "Finally, still in the anonymous function I passed to `flatMap`, I use Scala's `Array.map` (_not_ `RDD.map`) to transform each `word` into a tuple of the form `((word, fileName), 1)`.\n\n```scala\n    words.map(word => ((word, fileName), 1))\n```\n\nWhy did I embed a tuple of `(word, fileName)` inside the \"outer\" tuple with a `1` as the second element? Why not just write a three-element tuple, `(word, fileName, 1)`? I'll use the `(word, fileName)` as a _key_ in the next step, where I'll find all unique word-fileName combinations (using the equivalent of a `group by` statement). So, I need the nested `(word, fileName)` as my _key_. The `1` _value_ is a \"seed\" count, which I'll use to count the occurrences of the unique `(word, fileName)` pairs."
  }, {
    "metadata" : {
      "id" : "CB365E8B50C44DC88A0A4FB973D1AF0D"
    },
    "cell_type" : "markdown",
    "source" : "> **Notes:**\n> * For historical reasons, tuple indices start at 1, not 0. Arrays and other Scala collections index from 0.\n> * I said that _method_ arguments have to be declared with types. That's usually _not_ required for _function_ arguments, as here.\n> * Another benefit of triple-quoted strings that makes them nice for regular expressions is that you don't have to escape regular expression metacharacters, like `\\W`. If I used a single-quoted string, I would have to write it as `\"\\\\W+\"`. Your choice..."
  }, {
    "metadata" : {
      "id" : "08AA193D2F2043FA831DD736760C6CB8"
    },
    "cell_type" : "markdown",
    "source" : "Let's count the number of records we have and look at a few of the lines. We'll use the `RDD.take` method to grab the first 10 lines, then loop over them and print them."
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "id" : "41FF9807CE0B4FB59C59DEEA48A7E8A2"
    },
    "cell_type" : "code",
    "source" : "wordFileNameOnes.count",
    "outputs" : [ {
      "name" : "stdout",
      "output_type" : "stream",
      "text" : "res43: Long = 173336\n"
    }, {
      "metadata" : { },
      "data" : {
        "text/html" : "173336"
      },
      "output_type" : "execute_result",
      "execution_count" : 25
    } ]
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "id" : "AA2C8482A4874A2584B6DE64D387FE7D"
    },
    "cell_type" : "code",
    "source" : "wordFileNameOnes.take(10).foreach(println)",
    "outputs" : [ {
      "name" : "stdout",
      "output_type" : "stream",
      "text" : "((,midsummersnightsdream),1)\n((A,midsummersnightsdream),1)\n((MIDSUMMER,midsummersnightsdream),1)\n((NIGHT,midsummersnightsdream),1)\n((S,midsummersnightsdream),1)\n((DREAM,midsummersnightsdream),1)\n((DRAMATIS,midsummersnightsdream),1)\n((PERSONAE,midsummersnightsdream),1)\n((THESEUS,midsummersnightsdream),1)\n((Duke,midsummersnightsdream),1)\n"
    }, {
      "metadata" : { },
      "data" : {
        "text/html" : ""
      },
      "output_type" : "execute_result",
      "execution_count" : 26
    } ]
  }, {
    "metadata" : {
      "id" : "8BA9250ABA92441FA406F42C09C867AD"
    },
    "cell_type" : "markdown",
    "source" : "We asked for results, so we forced Spark to run a job to compute results. Spark pipelines, like `iiFirstPass1` are _lazy_; nothing is computed until we ask for results. \n\nWhen you're learning, it's useful to print some data to better understand what's happening. Just be aware of the extra overhead of running lots of Spark jobs.\n\nThe first record show has \"\" (blank) as the word:\n\n```\n((,asyoulikeit),1)\n```\n\nAlso, some words have all capital letters:\n\n```\n((DRAMATIS,asyoulikeit),1)\n```\n\n(You can see where these words occur in the original files.) Later on, We'll filter out the blank-word records and use lower case for all words."
  }, {
    "metadata" : {
      "id" : "82C274F9C74448B7817C504E07F920E3"
    },
    "cell_type" : "markdown",
    "source" : "Now, let's join all the unique `(word,fileName)` pairs together. "
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "id" : "8DD3365A4AA2402A9D2556F995961C00"
    },
    "cell_type" : "code",
    "source" : "val uniques = wordFileNameOnes.reduceByKey((count1, count2) => count1 + count2)\nuniques",
    "outputs" : [ {
      "name" : "stdout",
      "output_type" : "stream",
      "text" : "uniques: org.apache.spark.rdd.RDD[((String, String), Int)] = ShuffledRDD[13] at reduceByKey at <console>:64\nres47: org.apache.spark.rdd.RDD[((String, String), Int)] = ShuffledRDD[13] at reduceByKey at <console>:64\n"
    }, {
      "metadata" : { },
      "data" : {
        "text/html" : "ShuffledRDD[13] at reduceByKey at &lt;console&gt;:64"
      },
      "output_type" : "execute_result",
      "execution_count" : 27
    } ]
  }, {
    "metadata" : {
      "id" : "340390D700F34A198E099DF39FBBC74D"
    },
    "cell_type" : "markdown",
    "source" : "In SQL you would use `GROUP BY` for this (including in Spark's [DataFrame](http://spark.apache.org/docs/latest/sql-programming-guide.html) API. However, in the `RDD` API, this is too expensive for our needs, because we don't care about the groups, the long list of repeated `(word,fileName)` pairs. We only care about how many elements are in the groups, that is their _size_. That's the purpose of the `1` in the tuples and the use of `RDD.reduceByKey`. It brings together all records with the same key, the unique `(word,fileName)` pairs, and then applies the anonymous function to \"reduce\" the values, the `1s`. I simply sum them up to compute the group counts.\n\nNote that this anonymous function takes two arguments, so I need parentheses around the argument list. Since this function fits on the same line, I used parentheses for `reduceByKey`, instead of braces.\n\n> **Note:** All the `*ByKey` methods operate on two-element tuples and treat the first element as the key, by default."
  }, {
    "metadata" : {
      "id" : "93409D472EBF4C07BD74EA733D4D6296"
    },
    "cell_type" : "markdown",
    "source" : "How many are there? Let's see a few:"
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "id" : "17D9B46320474C17BD71A9EDA0F717E9"
    },
    "cell_type" : "code",
    "source" : "uniques.count",
    "outputs" : [ {
      "name" : "stdout",
      "output_type" : "stream",
      "text" : "res49: Long = 27276\n"
    }, {
      "metadata" : { },
      "data" : {
        "text/html" : "27276"
      },
      "output_type" : "execute_result",
      "execution_count" : 28
    } ]
  }, {
    "metadata" : {
      "id" : "DC87537AD03041868BF85C6645D4B72D"
    },
    "cell_type" : "markdown",
    "source" : "As you would expect from a `GROUP BY`-like statement, the number of records is smaller than before. There are about 1/6 as many records now, meaning that on average, each `(word,fileName)` combination appears 6 times."
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "id" : "15493734ED804BC484BF3DF21DEBDF6F"
    },
    "cell_type" : "code",
    "source" : "uniques.take(30).foreach(println)",
    "outputs" : [ {
      "name" : "stdout",
      "output_type" : "stream",
      "text" : "((crest,asyoulikeit),1)\n((force,muchadoaboutnothing),2)\n((whole,comedyoferrors),2)\n((lamb,muchadoaboutnothing),2)\n((blunt,tamingoftheshrew),3)\n((letter,merrywivesofwindsor),19)\n((dexterity,merrywivesofwindsor),1)\n((bestow,asyoulikeit),1)\n((rear,midsummersnightsdream),1)\n((crossing,tamingoftheshrew),1)\n((wronged,merrywivesofwindsor),4)\n((S,tamingoftheshrew),10)\n((HIPPOLYTA,midsummersnightsdream),19)\n((revolve,twelfthnight),1)\n((renown,asyoulikeit),1)\n((er,merrywivesofwindsor),11)\n((cubiculo,twelfthnight),1)\n((All,twelfthnight),3)\n((power,loveslabourslost),8)\n((Albeit,asyoulikeit),1)\n((lips,tamingoftheshrew),3)\n((upshot,twelfthnight),1)\n((approach,midsummersnightsdream),4)\n((mean,muchadoaboutnothing),5)\n((embossed,asyoulikeit),1)\n((varnish,loveslabourslost),2)\n((Apollo,midsummersnightsdream),1)\n((spangled,midsummersnightsdream),1)\n((gentlemen,comedyoferrors),1)\n((knowest,muchadoaboutnothing),1)\n"
    }, {
      "metadata" : { },
      "data" : {
        "text/html" : ""
      },
      "output_type" : "execute_result",
      "execution_count" : 29
    } ]
  }, {
    "metadata" : {
      "id" : "883847887BD84C2C8AFF71A63A87638F"
    },
    "cell_type" : "markdown",
    "source" : "For _inverted index_, we want our final keys to be the words themselves, so let's restructure the tuples from `((word,fileName),count)` to `(word,(fileName,count))`. Now, I'll still output two-element, key-value tuples, but the `word` will be the key and the `(fileName,count)` tuple will be the value."
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "id" : "B945394B877C4C1D8C601E446D5A856B"
    },
    "cell_type" : "code",
    "source" : "val words = uniques.map { word_file_count_tup3 => \n    (word_file_count_tup3._1._1, (word_file_count_tup3._1._2, word_file_count_tup3._2)) \n}",
    "outputs" : [ {
      "name" : "stdout",
      "output_type" : "stream",
      "text" : "words: org.apache.spark.rdd.RDD[(String, (String, Int))] = MapPartitionsRDD[14] at map at <console>:66\n"
    }, {
      "metadata" : { },
      "data" : {
        "text/html" : ""
      },
      "output_type" : "execute_result",
      "execution_count" : 30
    } ]
  }, {
    "metadata" : {
      "id" : "D2412BFCCAE942448B2F0F2A83755325"
    },
    "cell_type" : "markdown",
    "source" : "The nested tuple methods, e.g., `_1._2`, are hard to read, making the logic here somewhat obscure. We'll see a beautiful and elegant alternative shortly."
  }, {
    "metadata" : {
      "id" : "8017FCDB61244ABF982FEBD7EDE2FE30"
    },
    "cell_type" : "markdown",
    "source" : "Now I'll use an actual `group by` operation, because I now need to retain the \"groups\". Calling `RDD.groupByKey` uses the first tuple element, now just the `words`, to bring together all occurrences of the unique words. Next, I'll sort the result by word, ascending alphabetically."
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "id" : "3A55E6B49D8E4E1D85F8DE4B3715F750"
    },
    "cell_type" : "code",
    "source" : "val wordGroups = words.groupByKey.sortByKey(ascending = true)\nwordGroups",
    "outputs" : [ {
      "name" : "stdout",
      "output_type" : "stream",
      "text" : "wordGroups: org.apache.spark.rdd.RDD[(String, Iterable[(String, Int)])] = ShuffledRDD[18] at sortByKey at <console>:68\nres54: org.apache.spark.rdd.RDD[(String, Iterable[(String, Int)])] = ShuffledRDD[18] at sortByKey at <console>:68\n"
    }, {
      "metadata" : { },
      "data" : {
        "text/html" : "ShuffledRDD[18] at sortByKey at &lt;console&gt;:68"
      },
      "output_type" : "execute_result",
      "execution_count" : 31
    } ]
  }, {
    "metadata" : {
      "id" : "EF406143D451401B938CC7CBC3102B54"
    },
    "cell_type" : "markdown",
    "source" : "Note that the \"group\" is actually a Scala [Iterable](http://www.scala-lang.org/api/current/index.html#scala.collection.Iterable), i.e., an abstraction for some sort of collection. I't actually a Spark-defined, private collection type called a `CompactBuffer`."
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "id" : "0591CBBB7ED04BC18313CC4B8DD11F22"
    },
    "cell_type" : "code",
    "source" : "wordGroups.count",
    "outputs" : [ {
      "name" : "stdout",
      "output_type" : "stream",
      "text" : "res56: Long = 11951\n"
    }, {
      "metadata" : { },
      "data" : {
        "text/html" : "11951"
      },
      "output_type" : "execute_result",
      "execution_count" : 32
    } ]
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "id" : "0238CC44E40444DDB43D53ACCBBA6513"
    },
    "cell_type" : "code",
    "source" : "wordGroups.take(30).foreach(println)",
    "outputs" : [ {
      "name" : "stdout",
      "output_type" : "stream",
      "text" : "(,CompactBuffer((tamingoftheshrew,1), (asyoulikeit,1), (merrywivesofwindsor,1), (comedyoferrors,1), (midsummersnightsdream,1), (twelfthnight,1), (loveslabourslost,1), (muchadoaboutnothing,1)))\n(A,CompactBuffer((loveslabourslost,78), (midsummersnightsdream,39), (muchadoaboutnothing,31), (merrywivesofwindsor,38), (comedyoferrors,42), (asyoulikeit,34), (twelfthnight,47), (tamingoftheshrew,59)))\n(ABOUT,CompactBuffer((muchadoaboutnothing,18)))\n(ACT,CompactBuffer((asyoulikeit,22), (comedyoferrors,11), (tamingoftheshrew,12), (loveslabourslost,9), (muchadoaboutnothing,17), (twelfthnight,18), (merrywivesofwindsor,23), (midsummersnightsdream,9)))\n(ADAM,CompactBuffer((asyoulikeit,16)))\n(ADO,CompactBuffer((muchadoaboutnothing,18)))\n(ADRIANA,CompactBuffer((comedyoferrors,85)))\n(ADRIANO,CompactBuffer((loveslabourslost,111)))\n(AEGEON,CompactBuffer((comedyoferrors,20)))\n(AEMELIA,CompactBuffer((comedyoferrors,16)))\n(AEMILIA,CompactBuffer((comedyoferrors,3)))\n(AEacides,CompactBuffer((tamingoftheshrew,1)))\n(AEgeon,CompactBuffer((comedyoferrors,7)))\n(AEgle,CompactBuffer((midsummersnightsdream,1)))\n(AEmilia,CompactBuffer((comedyoferrors,4)))\n(AEsculapius,CompactBuffer((merrywivesofwindsor,1)))\n(AGUECHEEK,CompactBuffer((twelfthnight,2)))\n(ALL,CompactBuffer((midsummersnightsdream,2), (tamingoftheshrew,2)))\n(AMIENS,CompactBuffer((asyoulikeit,16)))\n(ANDREW,CompactBuffer((twelfthnight,104)))\n(ANGELO,CompactBuffer((comedyoferrors,36)))\n(ANN,CompactBuffer((merrywivesofwindsor,1)))\n(ANNE,CompactBuffer((merrywivesofwindsor,27)))\n(ANTIPHOLUS,CompactBuffer((comedyoferrors,195)))\n(ANTONIO,CompactBuffer((muchadoaboutnothing,32), (twelfthnight,32)))\n(ARMADO,CompactBuffer((loveslabourslost,111)))\n(AS,CompactBuffer((asyoulikeit,24)))\n(AUDREY,CompactBuffer((asyoulikeit,18)))\n(Abate,CompactBuffer((midsummersnightsdream,1), (loveslabourslost,1)))\n(Abbess,CompactBuffer((comedyoferrors,2)))\n"
    }, {
      "metadata" : { },
      "data" : {
        "text/html" : ""
      },
      "output_type" : "execute_result",
      "execution_count" : 33
    } ]
  }, {
    "metadata" : {
      "id" : "2A2C2E4A954A40718D3E9059EAE0D08C"
    },
    "cell_type" : "markdown",
    "source" : "Finally, let's clean up these `CompactBuffers`. Let's convert each to a Scala [Vector](http://www.scala-lang.org/api/current/index.html#scala.collection.immutable.Vector) (a collection with _O(1)_ performance for most operations), then sort it _descending_ by count, so the locations that mention the corresponding word the _most_ appear _first_ in the list. Note we're using `Vector.sortBy`, not an `RDD` sorting method. It takes a function that accepts each collection element and returns something used to sort the collection. By returning `(-fileNameCountTuple2._2, fileNameCountTuple2)`, I effectively say, \"sort by the counts _descending_ first, then the file names.\" Why does `-fileNameCountTuple2._2` cause counts to be sorted descending, because I'm returning the negative of the value, so larger counts will be less than smaller counts, e.g., `-3 < -2`.\n\nFinally, I take the resulting `Vector` and make a comma-separated string with the elements, using the helper method `mkString`.\n\nWhat's `RDD.mapValues`? I could use `RDD.map`, but I'm not changing the keys (the words), so rather than have to deal with the tuple with both elements, `mapValues` just passes in the value part of the tuple and reconstructs new `(key,value)` tuples with the new value that my function returns. So, `mapValues` is more convenient to use than `map` when I have two-element tuples and I'm not modifying the keys."
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "id" : "016D0589F20E40B58212D382F9A2FEC8"
    },
    "cell_type" : "code",
    "source" : "val iiFirstPass2 = wordGroups.mapValues { iterable => \n    val vect = iterable.toVector.sortBy { file_count_tup2 => \n        (-file_count_tup2._2, file_count_tup2._1)\n    }\n    vect.mkString(\",\")\n}",
    "outputs" : [ {
      "name" : "stdout",
      "output_type" : "stream",
      "text" : "iiFirstPass2: org.apache.spark.rdd.RDD[(String, String)] = MapPartitionsRDD[19] at mapValues at <console>:70\n"
    }, {
      "metadata" : { },
      "data" : {
        "text/html" : ""
      },
      "output_type" : "execute_result",
      "execution_count" : 34
    } ]
  }, {
    "metadata" : {
      "id" : "7C7007C29F564BBB852779540111D12D"
    },
    "cell_type" : "markdown",
    "source" : "We're done! The number of records is the same as for `wordGroups` (do you understand why?), so let's just see see some of the records."
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "id" : "9F721446ECFC4A5A8A82ECC97D49BF17"
    },
    "cell_type" : "code",
    "source" : "iiFirstPass2.take(30).foreach(println)",
    "outputs" : [ {
      "name" : "stdout",
      "output_type" : "stream",
      "text" : "(,(asyoulikeit,1),(comedyoferrors,1),(loveslabourslost,1),(merrywivesofwindsor,1),(midsummersnightsdream,1),(muchadoaboutnothing,1),(tamingoftheshrew,1),(twelfthnight,1))\n(A,(loveslabourslost,78),(tamingoftheshrew,59),(twelfthnight,47),(comedyoferrors,42),(midsummersnightsdream,39),(merrywivesofwindsor,38),(asyoulikeit,34),(muchadoaboutnothing,31))\n(ABOUT,(muchadoaboutnothing,18))\n(ACT,(merrywivesofwindsor,23),(asyoulikeit,22),(twelfthnight,18),(muchadoaboutnothing,17),(tamingoftheshrew,12),(comedyoferrors,11),(loveslabourslost,9),(midsummersnightsdream,9))\n(ADAM,(asyoulikeit,16))\n(ADO,(muchadoaboutnothing,18))\n(ADRIANA,(comedyoferrors,85))\n(ADRIANO,(loveslabourslost,111))\n(AEGEON,(comedyoferrors,20))\n(AEMELIA,(comedyoferrors,16))\n(AEMILIA,(comedyoferrors,3))\n(AEacides,(tamingoftheshrew,1))\n(AEgeon,(comedyoferrors,7))\n(AEgle,(midsummersnightsdream,1))\n(AEmilia,(comedyoferrors,4))\n(AEsculapius,(merrywivesofwindsor,1))\n(AGUECHEEK,(twelfthnight,2))\n(ALL,(midsummersnightsdream,2),(tamingoftheshrew,2))\n(AMIENS,(asyoulikeit,16))\n(ANDREW,(twelfthnight,104))\n(ANGELO,(comedyoferrors,36))\n(ANN,(merrywivesofwindsor,1))\n(ANNE,(merrywivesofwindsor,27))\n(ANTIPHOLUS,(comedyoferrors,195))\n(ANTONIO,(muchadoaboutnothing,32),(twelfthnight,32))\n(ARMADO,(loveslabourslost,111))\n(AS,(asyoulikeit,24))\n(AUDREY,(asyoulikeit,18))\n(Abate,(loveslabourslost,1),(midsummersnightsdream,1))\n(Abbess,(comedyoferrors,2))\n"
    }, {
      "metadata" : { },
      "data" : {
        "text/html" : ""
      },
      "output_type" : "execute_result",
      "execution_count" : 35
    } ]
  }, {
    "metadata" : {
      "id" : "D54E35935C124319897560C95FED8D8D"
    },
    "cell_type" : "markdown",
    "source" : "Okay. Looks reasonable. \n\nNext, I'll refine the code using a very powerful feature, _pattern matching_, which both makes the code more concise and easier to understand. It's my favorite feature of Scala.\n\nBefore I do that, try a few refinements on your own.\n\n**Exercises:**\n\n* Add a filter statement to remove the first entry for the blank word \"\". You could do this one of two ways, using another \"step\" with [RDD.filter](http://spark.apache.org/docs/latest/api/scala/index.html#org.apache.spark.rdd.RDD) (search the [Scaladoc page]((http://spark.apache.org/docs/latest/api/scala/index.html#org.apache.spark.rdd.RDD) for the `filter` method), _or_ using the similar Scala collections method, [scala.collection.Seq.filter](http://www.scala-lang.org/api/current/index.html#scala.collection.Seq). Both versions take a _predicate_ function, one that returns `true` if the record should be _retained_ and `false` otherwise. Do you think one choice is better than the other? Why? Or, are they basically the same? Reasons might include code comprehension and performance of one over the other.\n* Convert all words to lower case. Calling `toLowerCase` on a string is all you need. Where's a good place to insert this logic?\n\nI'll implement both changes in subsequent refinements below."
  }, {
    "metadata" : {
      "id" : "548A5954DA12488B8A0E641AF902DB2D"
    },
    "cell_type" : "markdown",
    "source" : "> **NOTE:** If you would prefer to make a copy of the code in a new cell, use the _Insert_ menu above to add cells. Or, learn another keyboard shortcut; `ESC` (escape key), followed by `A` for insert before or `B` for insert after. Then hit return to edit. Note the toolbar pop-down for setting the format of the cell. This cell you're reading is _Markdown_. Make sure to use _Code_ for your source code cells."
  }, {
    "metadata" : {
      "id" : "BC161EB30C3B4F4EA5E341E88523BE8C"
    },
    "cell_type" : "markdown",
    "source" : "## Pattern Matching\nWe've studied a real program and we've learned quite a bit of Scala. Let's improve it with my favorite Scala feature, _pattern matching_.\n\nHere's the \"first pass\" version again for easy reference."
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "id" : "DA1A70091E8E4407A223F8AB9E2F1E62"
    },
    "cell_type" : "code",
    "source" : "val iiFirstPass1b = sc.wholeTextFiles(shakespeare.toString).\n    flatMap { location_contents_tuple2 => \n        val words = location_contents_tuple2._2.split(\"\"\"\\W+\"\"\")\n        val fileName = location_contents_tuple2._1.split(pathSeparator).last\n        words.map(word => ((word, fileName), 1))\n    }.\n    reduceByKey((count1, count2) => count1 + count2).\n    map { word_file_count_tup3 => \n        (word_file_count_tup3._1._1, (word_file_count_tup3._1._2, word_file_count_tup3._2)) \n    }.\n    groupByKey.\n    sortByKey(ascending = true).\n    mapValues { iterable => \n        val vect = iterable.toVector.sortBy { file_count_tup2 => \n            (-file_count_tup2._2, file_count_tup2._1)\n        }\n        vect.mkString(\",\")\n    }",
    "outputs" : [ {
      "name" : "stdout",
      "output_type" : "stream",
      "text" : "iiFirstPass1b: org.apache.spark.rdd.RDD[(String, String)] = MapPartitionsRDD[29] at mapValues at <console>:80\n"
    }, {
      "metadata" : { },
      "data" : {
        "text/html" : ""
      },
      "output_type" : "execute_result",
      "execution_count" : 36
    } ]
  }, {
    "metadata" : {
      "id" : "B776C7F5F9E04F5B8D15EEEA2B1CDAC2"
    },
    "cell_type" : "markdown",
    "source" : "Now here is a new implementation that uses _pattern matching_. \n\nI've also made two other additions, the solutions to the last exercises, which remove empty words \"\" and fix mixed capitalization, using the following additions:\n* `filter(word => word.size > 0)` to remove the empty words. (In Spark and Scala collections, `filter` has the positive sense; what should be retained?) It's indicated by the comment `// #1`.\n* `word.toLowerCase` to convert all words to lower case uniformly, so that words like HAMLET, Hamlet, and hamlet in the original texts are treated as the same, since we're counting word occurrences. See comment `// #2`."
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "id" : "4AC1B06955A74550AF9304053604DEEC"
    },
    "cell_type" : "code",
    "source" : "val ii1 = sc.wholeTextFiles(shakespeare.toString).\n    flatMap {\n        case (location, contents) => \n            val words = contents.split(\"\"\"\\W+\"\"\").\n                filter(word => word.size > 0)                      // #1\n            val fileName = location.split(pathSeparator).last\n            words.map(word => ((word.toLowerCase, fileName), 1))   // #2\n    }.\n    reduceByKey((count1, count2) => count1 + count2).\n    map { \n        case ((word, fileName), count) => (word, (fileName, count)) \n    }.\n    groupByKey.\n    sortByKey(ascending = true).\n    mapValues { iterable => \n        val vect = iterable.toVector.sortBy { \n            case (fileName, count) => (-count, fileName) \n        }\n        vect.mkString(\",\")\n    }",
    "outputs" : [ {
      "name" : "stdout",
      "output_type" : "stream",
      "text" : "ii1: org.apache.spark.rdd.RDD[(String, String)] = MapPartitionsRDD[39] at mapValues at <console>:82\n"
    }, {
      "metadata" : { },
      "data" : {
        "text/html" : ""
      },
      "output_type" : "execute_result",
      "execution_count" : 37
    } ]
  }, {
    "metadata" : {
      "id" : "AEFCD90AF8BF4D9C8944AAAC966D885D"
    },
    "cell_type" : "markdown",
    "source" : "Compare with your exercise solutions above. I added the filtering inside the function passed to `flatMap`. My choice reduces the number of output records from `flatMap` by at most one record per input line, which shouldn't have a significant impact on performance. Filtering itself adds some extra overhead. \n\nAlso, the way Spark implements steps like `map`, `flatMap`, `filter`, it would incur about the same overhead if I used `RDD.filter` instead. Note that we could also do the filtering later in the pipeline, after `groupByKey`, for example. So, whichever approach you implemented above is probably fine. You could do performance profiling of the different approaches, but you may not notice a significance difference until you use very large input data sets.\n\nLet's verify we still get reasonable results. Now I'll use Spark's [DataFrame](http://spark.apache.org/docs/latest/api/scala/index.html#org.apache.spark.sql.DataFrame) API for its convenient display options. `DataFrames` are part of [Spark SQL](http://spark.apache.org/docs/latest/sql-programming-guide.html). We'll start by creating an instance of [SQLContext](http://spark.apache.org/docs/latest/api/scala/index.html#org.apache.spark.sql.SQLContext) that we need to access these features."
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "id" : "ABB91A9A1526418A8BDAFA19CD2DD5FB"
    },
    "cell_type" : "code",
    "source" : "import org.apache.spark.sql.SQLContext\nval sqlContext = new SQLContext(sc)",
    "outputs" : [ {
      "name" : "stdout",
      "output_type" : "stream",
      "text" : "import org.apache.spark.sql.SQLContext\nsqlContext: org.apache.spark.sql.SQLContext = org.apache.spark.sql.SQLContext@26445b16\n"
    }, {
      "metadata" : { },
      "data" : {
        "text/html" : ""
      },
      "output_type" : "execute_result",
      "execution_count" : 40
    } ]
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "id" : "5E1532F5A88042F685A3E759E749B2E1"
    },
    "cell_type" : "code",
    "source" : "val ii1DF = sqlContext.createDataFrame(ii1).toDF(\"word\", \"locations_counts\")",
    "outputs" : [ {
      "name" : "stdout",
      "output_type" : "stream",
      "text" : "ii1DF: org.apache.spark.sql.DataFrame = [word: string, locations_counts: string]\n"
    }, {
      "metadata" : { },
      "data" : {
        "text/html" : ""
      },
      "output_type" : "execute_result",
      "execution_count" : 42
    } ]
  }, {
    "metadata" : {
      "id" : "D047BDFA0EC64794865588169B7BB8D4"
    },
    "cell_type" : "markdown",
    "source" : "If we ask for the value of a DataFrame, Spark Notebook renders it with a paged, table view."
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "id" : "92EAFF4259D84EAD8076DFE88562A1ED"
    },
    "cell_type" : "code",
    "source" : "ii1DF",
    "outputs" : [ {
      "name" : "stdout",
      "output_type" : "stream",
      "text" : "res70: org.apache.spark.sql.DataFrame = [word: string, locations_counts: string]\n"
    }, {
      "metadata" : { },
      "data" : {
        "text/html" : "<div class=\"df-canvas\">\n      <script data-this=\"{&quot;dataId&quot;:&quot;anon00a54510978f7463b01ded5ece350f70&quot;,&quot;partitionIndexId&quot;:&quot;anon94c450b4fc0efe21ab66723da68e192c&quot;,&quot;numPartitions&quot;:417,&quot;dfSchema&quot;:{&quot;type&quot;:&quot;struct&quot;,&quot;fields&quot;:[{&quot;name&quot;:&quot;word&quot;,&quot;type&quot;:&quot;string&quot;,&quot;nullable&quot;:true,&quot;metadata&quot;:{}},{&quot;name&quot;:&quot;locations_counts&quot;,&quot;type&quot;:&quot;string&quot;,&quot;nullable&quot;:true,&quot;metadata&quot;:{}}]}}\" type=\"text/x-scoped-javascript\">/*<![CDATA[*/req(['../javascripts/notebook/dataframe','../javascripts/notebook/consoleDir'], \n      function(dataframe, extension) {\n        dataframe.call(data, this, extension);\n      }\n    );/*]]>*/</script>\n      <link rel=\"stylesheet\" href=\"/assets/stylesheets/ipython/css/dataframe.css\" type=\"text/css\"/>\n    </div>"
      },
      "output_type" : "execute_result",
      "execution_count" : 43
    } ]
  }, {
    "metadata" : {
      "id" : "BD278B27A85248358992E2C828710B45"
    },
    "cell_type" : "markdown",
    "source" : "Now let's explore the new implementation. I start off as before, by calling `wholeTextFiles`:\n\n```scala\nval ii = sc.wholeTextFiles(shakespeare.toString).\n```"
  }, {
    "metadata" : {
      "id" : "D76E82AA12614AC68EB2234331AF8553"
    },
    "cell_type" : "markdown",
    "source" : "The function I pass to `flatMap` now looks like this:\n\n```scala\nflatMap { \n    case (location, contents) => \n        val words = contents.split(\"\"\"\\W+\"\"\").\n            filter(word => word.size > 0)                      // #1\n        val fileName = location.split(pathSeparator).last\n        words.map(word => ((word.toLowerCase, fileName), 1))   // #2\n}.\n```\n\nCompare it to the previous version (ignoring the enhancements for blank words and capitalization, marked with the \\#1 and \\#2 comments):\n\n```scala\nflatMap { location_contents_tuple2 => \n    val words = location_contents_tuple2._2.split(\"\"\"\\W+\"\"\")\n    val fileName = location_contents_tuple2._1.split(pathSeparator).last\n    words.map(word => ((word, fileName), 1))\n}.\n```    \n\nInstead of `location_contents_tuple2` a variable name for the whole tuple, I wrote `case (location, contents)`. The `case` keyword says I want to _pattern match_ on the object passed to the function. If it's a two-element tuple (and I know it always will be in this case), then _extract_ the first element and assign it to a variable named `location` and extract the second element and assign it to a variable named `contents`.\n\nNow, instead of accessing the location and content with the slighly obscure and verbose `location_contents_tuple2._1` and `location_contents_tuple2._2`, respectively, I use meaningful names, `location` and `contents`. The code becomes more concise and more readable. \n\nI'll explore more pattern matching features below."
  }, {
    "metadata" : {
      "id" : "F6C55F95192341F6844A0B38FB7FAA49"
    },
    "cell_type" : "markdown",
    "source" : "The `reduceByKey` step is unchanged:\n\n```scala\nreduceByKey((count1, count2) => count1 + count2).\n```\n\nTo be clear, this isn't a pattern-matching expression; there is no `case` keyword. It's just a \"regular\" function that takes two arguments, for the two things I'm adding."
  }, {
    "metadata" : {
      "id" : "52B6F792A97945EC918C3700D42AE7D6"
    },
    "cell_type" : "markdown",
    "source" : "My favorite improvement is the next line:\n\n```scala\nmap { \n    case ((word, fileName), count) => (word, (fileName, count)) \n}.\n```\n\nCompare it to the previous, obscure version:\n\n```\nmap { word_file_count_tup3 => \n    (word_file_count_tup3._1._1, (word_file_count_tup3._1._2, word_file_count_tup3._2)) \n}.\n```\n\nThe new implementation makes it clear what I'm doing; just shifting parentheses! That's all it takes to go from the `(word, fileName)` keys with `count` values to `word` keys and `(fileName, count)` values. Note that pattern matching works just fine with nested structures, like `((word, fileName), count)`.\n\nI hope you can appreciate how elegant and concise this expression is! Note how I thought of the next transformation I needed to do in preparation for the final group-by, to switch from `((word, fileName), count)` to `(word, (fileName, count))` and _I just wrote it down exactly as I pictured it!_\n\nCode like this makes writing Scala Spark code a sublime experience."
  }, {
    "metadata" : {
      "id" : "292E580C8360480D9663AE1957D947AC"
    },
    "cell_type" : "markdown",
    "source" : "The next two expressions are unchanged:\n\n```scala\ngroupByKey.\nsortByKey(ascending = true).\n```"
  }, {
    "metadata" : {
      "id" : "5E27729F18C5497CA12FCEF9C971F855"
    },
    "cell_type" : "markdown",
    "source" : "The final `mapValues` now uses pattern matching to sort the `Vector` in each record:\n\n```scala\nmapValues { iterable => \n    val vect = iterable.toVector.sortBy { \n        case (fileName, count) => (-count, fileName) \n    }\n    vect.mkString(\",\")\n}\n```\n\nCompared to the original version, it's again easier to read:\n\n```scala\nmapValues { iterable => \n    val vect = iterable.toVector.sortBy { file_count_tup2 => \n        (-file_count_tup2._2, file_count_tup2._1)\n    }\n    vect.mkString(\",\")\n}\n```"
  }, {
    "metadata" : {
      "id" : "D2C026C6C6E641BD81DEA55690F987AE"
    },
    "cell_type" : "markdown",
    "source" : "The function I pass to `sortBy` returns a tuple used for sorting, with `-count` to force _descending_ numerical sort (biggest first) and `fileName` to secondarily sort by the file name, for equivalent counts. I could ignore file name order and just return `-count` (not a tuple). However, if you need more repeatable output in a distributed system like Spark, say for example to use in unit test validation, then the secondary sorting by file name is handy."
  }, {
    "metadata" : {
      "id" : "C224719DD3084F0A9D81A85E693E40D1"
    },
    "cell_type" : "markdown",
    "source" : "## Our Final Version: Supporting SQL Queries\nBy the way, we can write SQL queries to explore the resulting data. \n\nTo do this, let's first refine the output. Instead of creating a string for the list of `(location,count)` pairs, which is opaque to our SQL schema (i.e., just a string), let's \"unzip\" the collection into two arrays, one for the `locations` and one for the `counts`. That way, if we ask for the first element of each array, we'll have nicely separate fields that work better with Spark SQL queries.\n\nHere is our final implementation, `ii1` rewritten with this change."
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "id" : "120CBF8222CD4483BB8DD4EBDC7A3ED5"
    },
    "cell_type" : "code",
    "source" : "val ii = sc.wholeTextFiles(shakespeare.toString).\n    flatMap {\n        case (location, contents) => \n            val words = contents.split(\"\"\"\\W+\"\"\").\n                filter(word => word.size > 0)                      // #1\n            val fileName = location.split(pathSeparator).last\n            words.map(word => ((word.toLowerCase, fileName), 1))   // #2\n    }.\n    reduceByKey((count1, count2) => count1 + count2).\n    map { \n        case ((word, fileName), count) => (word, (fileName, count)) \n    }.\n    groupByKey.\n    sortByKey(ascending = true).\n    map {                         // Must use map now, because we'll format new records. \n      case (word, iterable) =>    // Hence, pattern match on the whole input record.\n\n        val vect = iterable.toVector.sortBy { \n            case (fileName, count) => (-count, fileName) \n        }\n\n        // Use `Vector.unzip`, which returns a single, two element tuple, where each\n        // element is a collection, one for the locations and one for the counts. \n        // I use pattern matching to extract these two collections into variables.\n        val (locations, counts) = vect.unzip  \n        \n        // Lastly, I'll compute the total count across all locations and return \n        // a new record with all four fields. The `reduceLeft` method takes a function\n        // that knows how to \"reduce\" the collection down to a final value, working \n        // from the left.\n        val totalCount = counts.reduceLeft((n1,n2) => n1+n2)\n        \n        (word, totalCount, locations, counts)\n    }",
    "outputs" : [ {
      "name" : "stdout",
      "output_type" : "stream",
      "text" : "ii: org.apache.spark.rdd.RDD[(String, Int, scala.collection.immutable.Vector[String], scala.collection.immutable.Vector[Int])] = MapPartitionsRDD[55] at map at <console>:83\n"
    }, {
      "metadata" : { },
      "data" : {
        "text/html" : ""
      },
      "output_type" : "execute_result",
      "execution_count" : 44
    } ]
  }, {
    "metadata" : {
      "id" : "DE48F43EDC0B4FE983B358F999D1F00F"
    },
    "cell_type" : "markdown",
    "source" : "We've changed the ending `mapValues` call to a `map` call, because we'll construct entirely new records, not just new values with the same keys. Hence the full records, two-element tuples are passed in, rather than just the values, so we'll pattern match on the tuple:\n\n\n```scala\n    map {                         // Must use map now, because we'll format new records.\n      case (word, iterable) =>    // Hence, pattern match on the whole input record.\n\n        val vect = iterable.toVector.sortBy { \n            case (fileName, count) => (-count, fileName) \n        }\n```\n\n\nWe have a `Vector[String, Int]` of two-element tuples `(fileName, count)`. We use `Vector.unzip` to create a single, two element tuple, where each element is now a collection, one for the locations and one for the counts. The type is `(Vector[String], Vector[Int])`.\n\nWe can also use pattern matching with assignment! We immediately decompose the two-element tuple:\n\n```scala\n        // I use pattern matching to extract these two collections into variables.\n        val (locations, counts) = vect.unzip  \n```\n\nFinally, it's convenient to know how many locations and counts we have, so we'll compute another new column for the their count and format a four-element tuple as the final output.\n\n```scala\n        // Lastly, I'll compute the total count across all locations and return \n        // a new record with all four fields. The `reduceLeft` method takes a function\n        // that knows how to \"reduce\" the collection down to a final value, working \n        // from the left.\n        val totalCount = counts.reduceLeft((n1,n2) => n1+n2)\n\n        (word, totalCount, locations, counts)\n    }\n```    "
  }, {
    "metadata" : {
      "id" : "1B97941817A049CAA7F89263D1D8BFE6"
    },
    "cell_type" : "markdown",
    "source" : "Okay! Now let's create a [DataFrame](http://spark.apache.org/docs/latest/api/scala/index.html#org.apache.spark.sql.DataFrame) with this data. The `toDF` method just returns the same `DataFrame`, but with appropriate names for the columns, instead of the synthesized names that `createDataFrame` generates (e.g., `_c1`, `_c2`, etc.)\n\nCaching the `DataFrame` in memory prevents Spark from recomputing `ii` from the input files _every time_ I write a query!\n\nFinally, to use SQL, I need to \"register\" a temporary table."
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "id" : "ACACA5AC5DF9489CA03EFE559847B9D5"
    },
    "cell_type" : "code",
    "source" : "val iiDF = sqlContext.createDataFrame(ii).toDF(\"word\", \"total_count\", \"locations\", \"counts\")\niiDF.cache\niiDF.registerTempTable(\"inverted_index\")",
    "outputs" : [ {
      "name" : "stdout",
      "output_type" : "stream",
      "text" : "iiDF: org.apache.spark.sql.DataFrame = [word: string, total_count: int, locations: array<string>, counts: array<int>]\n"
    }, {
      "metadata" : { },
      "data" : {
        "text/html" : ""
      },
      "output_type" : "execute_result",
      "execution_count" : 45
    } ]
  }, {
    "metadata" : {
      "id" : "B3E7EFA85D784E519ABA70036450AB3F"
    },
    "cell_type" : "markdown",
    "source" : "Let's remind ourselves of the schema:"
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "id" : "A0FF2B70D76043318104BAD9ECF67BF5"
    },
    "cell_type" : "code",
    "source" : "iiDF.printSchema",
    "outputs" : [ {
      "name" : "stdout",
      "output_type" : "stream",
      "text" : "root\n |-- word: string (nullable = true)\n |-- total_count: integer (nullable = false)\n |-- locations: array (nullable = true)\n |    |-- element: string (containsNull = true)\n |-- counts: array (nullable = true)\n |    |-- element: integer (containsNull = false)\n\n"
    }, {
      "metadata" : { },
      "data" : {
        "text/html" : ""
      },
      "output_type" : "execute_result",
      "execution_count" : 46
    } ]
  }, {
    "metadata" : {
      "id" : "DD372976F9D44EC48FEB02697BF7AE74"
    },
    "cell_type" : "markdown",
    "source" : "The following SQL query extracts the top location by count for each word, as well as the total count across all locations for the word. The Spark SQL dialect supports Hive SQL syntax for extracting elements from arrays, maps, and structs ([details](https://cwiki.apache.org/confluence/display/Hive/LanguageManual+UDF#LanguageManualUDF-CollectionFunctions)). Here I access the first element (index zero) from each array. "
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "id" : "B5A8A092E0C84E4E87112E0181CE38B5"
    },
    "cell_type" : "code",
    "source" : ":sql SELECT word, total_count, locations[0] AS top_location, counts[0] AS top_count \nFROM inverted_index \n",
    "outputs" : [ {
      "name" : "stdout",
      "output_type" : "stream",
      "text" : "import notebook.front.widgets.Sql\nimport notebook.front.widgets.Sql._\nres78: notebook.front.widgets.Sql = <Sql widget>\n"
    }, {
      "metadata" : { },
      "data" : {
        "text/html" : "<p data-bind=\"text: value\"><script data-this=\"{&quot;valueId&quot;:&quot;anon1120a48b1f0c9777c67b24695db9061a&quot;}\" type=\"text/x-scoped-javascript\">/*<![CDATA[*/\nreq(\n['observable', 'knockout'],\nfunction (O, ko) {\n  ko.applyBindings({\n      value: O.makeObservable(valueId)\n    },\n    this\n  );\n});\n        /*]]>*/</script></p><p data-bind=\"text: value\">\n      <script data-this=\"{&quot;valueId&quot;:&quot;anon07e213c33c056bc5f7af80617bb94712&quot;}\" type=\"text/x-scoped-javascript\">/*<![CDATA[*/ req(\n              ['observable', 'knockout'],\n              function (O, ko) {\n                ko.applyBindings({\n                    value: O.makeObservable(valueId)\n                  },\n                  this\n                );\n              }\n            );\n        /*]]>*/</script>\n    </p>"
      },
      "output_type" : "execute_result",
      "execution_count" : 48
    } ]
  }, {
    "metadata" : {
      "id" : "6C6F9CAE64B6461883CB25DCA0575F3F"
    },
    "cell_type" : "markdown",
    "source" : "Unfortunately, a current bug prevents us from seeing the result of the query, so let's use the Scala API to run it. Note that we'll use a triple-quoted string to make it easy to write the query across several lines. Since we assign the result to a variable, in order to see the table output, we ask for the value of `topLocations` after the assignment."
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "id" : "7AF28C5FA07B4F2794DB32A75B04B703"
    },
    "cell_type" : "code",
    "source" : "val topLocations = sqlContext.sql(\"\"\"\nSELECT word, total_count, locations[0] AS top_location, counts[0] AS top_count \nFROM inverted_index \n\"\"\")\ntopLocations",
    "outputs" : [ {
      "name" : "stdout",
      "output_type" : "stream",
      "text" : "topLocations: org.apache.spark.sql.DataFrame = [word: string, total_count: int, top_location: string, top_count: int]\nres87: org.apache.spark.sql.DataFrame = [word: string, total_count: int, top_location: string, top_count: int]\n"
    }, {
      "metadata" : { },
      "data" : {
        "text/html" : "<div class=\"df-canvas\">\n      <script data-this=\"{&quot;dataId&quot;:&quot;anon5baa3eeba01d270c6f96567e8e16d9ec&quot;,&quot;partitionIndexId&quot;:&quot;anon8ce923ffa829ec8e2af2d4ab021f598c&quot;,&quot;numPartitions&quot;:417,&quot;dfSchema&quot;:{&quot;type&quot;:&quot;struct&quot;,&quot;fields&quot;:[{&quot;name&quot;:&quot;word&quot;,&quot;type&quot;:&quot;string&quot;,&quot;nullable&quot;:true,&quot;metadata&quot;:{}},{&quot;name&quot;:&quot;total_count&quot;,&quot;type&quot;:&quot;integer&quot;,&quot;nullable&quot;:false,&quot;metadata&quot;:{}},{&quot;name&quot;:&quot;top_location&quot;,&quot;type&quot;:&quot;string&quot;,&quot;nullable&quot;:true,&quot;metadata&quot;:{}},{&quot;name&quot;:&quot;top_count&quot;,&quot;type&quot;:&quot;integer&quot;,&quot;nullable&quot;:true,&quot;metadata&quot;:{}}]}}\" type=\"text/x-scoped-javascript\">/*<![CDATA[*/req(['../javascripts/notebook/dataframe','../javascripts/notebook/consoleDir'], \n      function(dataframe, extension) {\n        dataframe.call(data, this, extension);\n      }\n    );/*]]>*/</script>\n      <link rel=\"stylesheet\" href=\"/assets/stylesheets/ipython/css/dataframe.css\" type=\"text/css\"/>\n    </div>"
      },
      "output_type" : "execute_result",
      "execution_count" : 53
    } ]
  }, {
    "metadata" : {
      "id" : "C24DF412925D422F963BA25EF2B0676F"
    },
    "cell_type" : "markdown",
    "source" : "A _natural language processing_ (NLP) expert might tell you that _love_, _loved_, _loves_, etc. are really the same word, because they are different conjugations of the verb _to love_ and _love_ is a noun, too. Similarly, should _gloves_ (plural) and _glove_ (singular) be handled differently?\n\nWhat we really should do is extract the _stems_ of these words and use those instead. NLP toolkits handle this _stemming_ for you."
  }, {
    "metadata" : {
      "id" : "D9F7860B6544491B8543ACCE24E1A27A"
    },
    "cell_type" : "markdown",
    "source" : "By the way, `DataFrames.show` has some optional arguments when you don't want to truncate the columns and you want to see a different number of rows than the default of 20."
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "id" : "1C89BA5AA15944DB85EB81C101B5A5E7"
    },
    "cell_type" : "code",
    "source" : "topLocations.show(numRows = 40, truncate = false)",
    "outputs" : [ {
      "name" : "stdout",
      "output_type" : "stream",
      "text" : "+-----------+-----------+---------------------+---------+\n|word       |total_count|top_location         |top_count|\n+-----------+-----------+---------------------+---------+\n|a          |3350       |loveslabourslost     |507      |\n|abandon    |6          |asyoulikeit          |4        |\n|abate      |3          |loveslabourslost     |1        |\n|abatement  |1          |twelfthnight         |1        |\n|abbess     |8          |comedyoferrors       |8        |\n|abbey      |9          |comedyoferrors       |9        |\n|abbominable|1          |loveslabourslost     |1        |\n|abbreviated|1          |loveslabourslost     |1        |\n|abed       |2          |asyoulikeit          |1        |\n|abetting   |1          |comedyoferrors       |1        |\n|abhominable|1          |loveslabourslost     |1        |\n|abhor      |5          |asyoulikeit          |1        |\n|abhors     |2          |twelfthnight         |2        |\n|abide      |5          |merrywivesofwindsor  |3        |\n|abides     |1          |muchadoaboutnothing  |1        |\n|ability    |2          |muchadoaboutnothing  |1        |\n|abject     |2          |comedyoferrors       |1        |\n|abjure     |1          |midsummersnightsdream|1        |\n|abjured    |2          |tamingoftheshrew     |1        |\n|able       |9          |merrywivesofwindsor  |4        |\n|aboard     |6          |comedyoferrors       |5        |\n|abode      |1          |tamingoftheshrew     |1        |\n|abominable |2          |asyoulikeit          |1        |\n|abortive   |1          |loveslabourslost     |1        |\n|abound     |1          |midsummersnightsdream|1        |\n|about      |108        |muchadoaboutnothing  |35       |\n|above      |22         |merrywivesofwindsor  |6        |\n|abraham    |2          |merrywivesofwindsor  |2        |\n|abridgement|1          |midsummersnightsdream|1        |\n|abroad     |3          |loveslabourslost     |2        |\n|abrogate   |1          |loveslabourslost     |1        |\n|abruptly   |1          |asyoulikeit          |1        |\n|absence    |7          |merrywivesofwindsor  |2        |\n|absent     |5          |asyoulikeit          |2        |\n|absolute   |1          |merrywivesofwindsor  |1        |\n|abstinence |1          |loveslabourslost     |1        |\n|abstract   |1          |merrywivesofwindsor  |1        |\n|abuse      |3          |merrywivesofwindsor  |2        |\n|abused     |11         |twelfthnight         |4        |\n|abuses     |2          |asyoulikeit          |2        |\n+-----------+-----------+---------------------+---------+\nonly showing top 40 rows\n\n"
    }, {
      "metadata" : { },
      "data" : {
        "text/html" : ""
      },
      "output_type" : "execute_result",
      "execution_count" : 54
    } ]
  }, {
    "metadata" : {
      "id" : "069FC6B00C0C4AB79121C9A9B1B71DE9"
    },
    "cell_type" : "markdown",
    "source" : "> **Note:** Named Parameters\n\n> I used _named parameters_ here, `show(numRows = 40, truncate = false)`, for legibility. They are optional in Scala, as long as you pass the values in the same order as the parameters are declared. You can also use named Parameters to write the arguments in any order you want, not just declaration order. So, I could have just written `(40, false)`, but then you would rightly wonder what `false` means in this context."
  }, {
    "metadata" : {
      "id" : "489DD9FF400A4109BF9B637B99269313"
    },
    "cell_type" : "markdown",
    "source" : "**Exercises:** \n\nSee the <a href=\"#ExerciseSolutions\">Appendix</a> for the solutions to the first two.\n\n* The `glove`, `gloves`, `whate` and `whatever` aren't really the `love` and `hate` we wanted ;) How might you change the query so be more specific.\n* Modify the query to return the top two locations and counts.\n* Before moving on, try writing other queries. Edit the query in the following cell:"
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "id" : "9EE20BF733134708B2531403E13C20C4"
    },
    "cell_type" : "code",
    "source" : "val sql1 = sqlContext.sql(\"\"\"\n    SELECT * FROM inverted_index\n\"\"\")\nsql1.show(10, false)",
    "outputs" : [ {
      "name" : "stdout",
      "output_type" : "stream",
      "text" : "+-----------+-----------+------------------------------------------------------------------------------------------------------------------------------------------------+----------------------------------------+\n|word       |total_count|locations                                                                                                                                       |counts                                  |\n+-----------+-----------+------------------------------------------------------------------------------------------------------------------------------------------------+----------------------------------------+\n|a          |3350       |[loveslabourslost, merrywivesofwindsor, muchadoaboutnothing, asyoulikeit, tamingoftheshrew, twelfthnight, midsummersnightsdream, comedyoferrors]|[507, 494, 492, 461, 445, 416, 281, 254]|\n|abandon    |6          |[asyoulikeit, tamingoftheshrew, twelfthnight]                                                                                                   |[4, 1, 1]                               |\n|abate      |3          |[loveslabourslost, midsummersnightsdream, tamingoftheshrew]                                                                                     |[1, 1, 1]                               |\n|abatement  |1          |[twelfthnight]                                                                                                                                  |[1]                                     |\n|abbess     |8          |[comedyoferrors]                                                                                                                                |[8]                                     |\n|abbey      |9          |[comedyoferrors]                                                                                                                                |[9]                                     |\n|abbominable|1          |[loveslabourslost]                                                                                                                              |[1]                                     |\n|abbreviated|1          |[loveslabourslost]                                                                                                                              |[1]                                     |\n|abed       |2          |[asyoulikeit, twelfthnight]                                                                                                                     |[1, 1]                                  |\n|abetting   |1          |[comedyoferrors]                                                                                                                                |[1]                                     |\n+-----------+-----------+------------------------------------------------------------------------------------------------------------------------------------------------+----------------------------------------+\nonly showing top 10 rows\n\nsql1: org.apache.spark.sql.DataFrame = [word: string, total_count: int, locations: array<string>, counts: array<int>]\n"
    }, {
      "metadata" : { },
      "data" : {
        "text/html" : ""
      },
      "output_type" : "execute_result",
      "execution_count" : 55
    } ]
  }, {
    "metadata" : {
      "id" : "19CA443F73DC490A9373828770C659E9"
    },
    "cell_type" : "markdown",
    "source" : "#### Removing the \"Stop Words\"\nDid you notice that one record we saw above was for the word \"a\". Not very useful if you're using this data for text searching, _sentiment mining_, etc. So called _stop words_, like _a_, _an_, _the_, _he_, _she_, _it_, etc., could also be removed.\n\nRecall the `filter` logic I added to remove \"\", `word => word.size > 0`. I could replace it with `word => keep(word)`, where `keep` is a method that does any additional filtering I want, like removing stop words.\n\n**Exercise:**\n\n* Implement the `keep(word: String):Boolean` method and change the `filter` function to use it. Have `keep` return `false` for a small, hard-coded list of stop words. (See the <a href=\"#ExerciseSolutions\">Appendix</a> for the solution.)"
  }, {
    "metadata" : {
      "id" : "53E07BA2AC3842E98DD0F66A5CF845EB"
    },
    "cell_type" : "markdown",
    "source" : "## More on Pattern Matching Syntax\nWe've only scratched the surface of pattern matching. Let's explore it some more.\n\nHere's another anonymous function using pattern matching that extends the previous function we passed to `flatMap`:\n\n```scala\n{\n    case (location, \"\") => \n        Array.empty[((String, String), Int)]  // Return an empty array\n    case (location, contents) => \n        val words = contents.split(\"\"\"\\W+\"\"\")\n        val fileName = location.split(pathSep).last\n        words.map(word => ((word, fileName), 1))\n}.\n```\n\nYou can have multiple `case` clauses, some of which might match on specific literal values (\"\" in this case) and others which are more general. The first case clause handles files with no content. The second clause is the same as before.\n\nPattern matching is _eager_. The first successful match in the order as written will win. If you reversed the order here, the `case (location, \"\")` would never match and the compiler would throw an \"unreachable code\" warning for it.\n\nNote that you don't have to put the lines after the `=>` inside braces, `{...}` (although you can). The `=>` and `case` keywords (or the final `}`) are sufficient to mark these blocks. Also, for a single-expression block, like the one for the first case clause, you can put the expression on the same line after the `=>` if you want (and it fits). \n\nFinally, if none of the case clauses matches, then a [MatchError](http://www.scala-lang.org/api/current/index.html#scala.MatchError) exception is thrown. In our case, we _always_ know we'll have two-element tuples, so the examples so far are fine. \n\nHere's a final contrived example to illustrate what's possible, using a sequence of objects of different types:"
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "id" : "A22422DA7F56403F83517E1DAD19D2A3"
    },
    "cell_type" : "code",
    "source" : "val stuff = Seq(1, 3.14159, 2L, 4.4F, (\"one\", 1), (404F, \"boo\"), ((11, 12), 21, 31), \"hello\")\n\nstuff.foreach {\n    case i: Int               => println(s\"Found an Int:   $i\")\n    case l: Long              => println(s\"Found a Long:   $l\")\n    case f: Float             => println(s\"Found a Float:  $f\")\n    case d: Double            => println(s\"Found a Double: $d\")\n    case (x1, x2) => \n        println(s\"Found a two-element tuple with elements of arbitrary type: ($x1, $x2)\")\n    case ((x1a, x1b), _, x3) => \n        println(s\"Found a three-element tuple with 1st and 3th elements: ($x1a, $x1b) and $x3\")\n    case default              => println(s\"Found something else: $default\")\n}",
    "outputs" : [ {
      "name" : "stdout",
      "output_type" : "stream",
      "text" : "Found an Int:   1\nFound a Double: 3.14159\nFound a Long:   2\nFound a Float:  4.4\nFound a two-element tuple with elements of arbitrary type: (one, 1)\nFound a two-element tuple with elements of arbitrary type: (404.0, boo)\nFound a three-element tuple with 1st and 3th elements: (11, 12) and 31\nFound something else: hello\nstuff: Seq[Any] = List(1, 3.14159, 2, 4.4, (one,1), (404.0,boo), ((11,12),21,31), hello)\n"
    }, {
      "metadata" : { },
      "data" : {
        "text/html" : ""
      },
      "output_type" : "execute_result",
      "execution_count" : 56
    } ]
  }, {
    "metadata" : {
      "id" : "8BB870235FCB4763898579F65A6B293E"
    },
    "cell_type" : "markdown",
    "source" : "A few notes.\n* A literal like `1` is inferred to be `Int`, while `3.14159` is inferred to be `Double`. Add `L` or `F`, respectively, to infer `Long` or `Float` instead.\n* Note how we mixed specific type checking, e.g., `i: Int`, with more loosely-typed expressions, e.g., `(x1, x2)`, which expects a two-element tuple, but the element types are unconstrained.\n* All the words `i`, `l`, `f`, `d`, `x1`, `x2`, `x3`, and `default` are arbitrary variable names. Yes `default` is not a keyword, but an arbitrary choice for a variable name. We could use anything we want.\n* The last `default` clause specifies a variable with no type information. Hence, it matches _anything_, which is why this clause must appear last. This is the idiom to use when you aren't sure about the types of things you're matching against and you want to avoid a possible [MatchError](http://www.scala-lang.org/api/current/index.html#scala.MatchError).\n* If you want to match that something _exists_, but you don't need to bind it to a variable, then use `_`, as in the three-element tuple example.\n* The three-element tuple example also demonstrates that arbitrary nesting of expressions is supported, where the first element is expected to be a two-element tuple.\n\nAll the anonymous functions we've seen that use these pattern matching clauses have this format:\n\n```scala\n{ \n    case firstCase => ...\n    case secondCase => ...\n    ... \n}```\n\nThis format has a special name. It's called a _partial function_. All that means is that we only \"promise\" to accept arguments that match at least one of our `case` clauses, not any possible input. \n\nThe other kind of anonymous function we've seen is a _total function_, to be precise. \n\nRecall we said that for total functions you can use either `(...)` or `{...}` around them, depending on the \"look\" you want. For _partial functions_, you _must_ use `{...}`."
  }, {
    "metadata" : {
      "id" : "3987C83C80DB4EC18399001B6148F0E4"
    },
    "cell_type" : "markdown",
    "source" : "Also, recall that we used pattern matching with assignment:\n\n```scala\nval (locations, counts) = vect.unzip  \n```\n[Vector.unzip](http://www.scala-lang.org/api/current/#scala.collection.immutable.Vector) returns a two-element tuple, where each element is a collection. We matched on that tuple and assigned each piece to a variable. Here's another contrived example, with nested tuple elements:"
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "id" : "F0BEF4E415EA47088CA07F8BDFD44E5D"
    },
    "cell_type" : "code",
    "source" : "val (a, (b, (c1, c2), d)) = (\"A\", (\"B\", (\"C1\", \"C2\"), \"D\"))\nprintln(s\" $a, $b, $c1, $c2, $d\")",
    "outputs" : [ {
      "name" : "stdout",
      "output_type" : "stream",
      "text" : " A, B, C1, C2, D\na: String = A\nb: String = B\nc1: String = C1\nc2: String = C2\nd: String = D\n"
    }, {
      "metadata" : { },
      "data" : {
        "text/html" : ""
      },
      "output_type" : "execute_result",
      "execution_count" : 57
    } ]
  }, {
    "metadata" : {
      "id" : "1EB1D204C073428E8226BDB65A013FF5"
    },
    "cell_type" : "markdown",
    "source" : "Try adding an `\"E\"` element to the tuple on the right-hand side, without changing the left-hand side. What happens? Try removing the `\"D\"` and `\"E\"` elements. What happens now?"
  }, {
    "metadata" : {
      "id" : "28CECBF1777C42E296EFB0CE1C6F858D"
    },
    "cell_type" : "markdown",
    "source" : "We'll come back to one last example of pattern matching when we discuss _case classes_."
  }, {
    "metadata" : {
      "id" : "BD1881613BF4402DA92CDC11B060B93A"
    },
    "cell_type" : "markdown",
    "source" : "## Scala's Object Model\nScala is a _hybrid_, object-oriented and functional programming language. The philosophy of Scala is that you exploit object orientation for encapsulation of details, i.e., _modularity_, but use functional programming for its logical precision when implementing those details. Most of what we've seen so far falls into the functional programming camp. Much of data manipulation and analysis is really Mathematics. Functional programming tries to stay close to how functions and values work in Mathematics.\n\nHowever, when writing non-trivial Spark programs, it's occasionally useful to exploit the object-oriented features."
  }, {
    "metadata" : {
      "id" : "4855076A7BC54D6C97D33A64EEFA0965"
    },
    "cell_type" : "markdown",
    "source" : "### Classes vs. Instances\nScala uses the same distinction between classes and instances that you find in Java. Classes are like _templates_ used to create instances. \n\nWe've talked about the _types_ of things, like `word` is a `String` and `totalCount` is an `Int`. A class defines a _type_ in the same sense.\n\nHere is an example class that we might use to represent the inverted index records we just created:"
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "id" : "E669C6B01CFE4ECCA6697FE314017013"
    },
    "cell_type" : "code",
    "source" : "class IIRecord1(\n    word: String, \n    total_count: Int, \n    locations: Array[String], \n    counts: Array[Int]) {\n    \n    /** CSV formatted string, but use [a,b,c] for the arrays */\n    override def toString: String = {\n        val locStr = locations.mkString(\"[\", \",\", \"]\")  // i.e., \"[a,b,c]\"\n        val cntStr = counts.mkString(\"[\", \",\", \"]\")  // i.e., \"[1,2,3]\"\n        s\"$word,$total_count,$locStr,$cntStr\"\n    }\n}\n\nnew IIRecord1(\"hello\", 3, Array(\"one\", \"two\"), Array(1, 2))",
    "outputs" : [ {
      "name" : "stdout",
      "output_type" : "stream",
      "text" : "defined class IIRecord1\nres97: IIRecord1 = hello,3,[one,two],[1,2]\n"
    }, {
      "metadata" : { },
      "data" : {
        "text/html" : "hello,3,[one,two],[1,2]"
      },
      "output_type" : "execute_result",
      "execution_count" : 58
    } ]
  }, {
    "metadata" : {
      "id" : "258FF28F533148E9828A26183A19E9F4"
    },
    "cell_type" : "markdown",
    "source" : "When defining a class, the argument list after the class name is the argument list for the _primary constructor_. You can define secondary constructors, too, but it's not very common, in part for reasons we'll see shortly.\n\nNote that when you override a method that's defined in a parent class, like Java's `Object.toString`, Scala requires you to add the `override` keyword.\n\nWe created an _instance_ of `IIRecord1` using `new`, just like in Java.\n\nFinally, as a side note, we've been using `Ints` (integers) all along for the various counts, but really for \"big data\", we should probably use `Longs`."
  }, {
    "metadata" : {
      "id" : "1DAC760FBC7A4F239981F119549B58E4"
    },
    "cell_type" : "markdown",
    "source" : "### Objects\n\nI've been careful to use the word _instance_ for things we create from classes. That's because Scala has built-in support for the [Singleton Design Pattern](https://en.wikipedia.org/wiki/Singleton_pattern), i.e., when we only want one instance of a class. We use the `object` keyword. \n\nFor example, in Java, you define a class with a `static void main(String[] arguments)` method as your entry point into your program. In Scala, you use an `object` to hold `main`, as follows:"
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "id" : "238A29DAC4E54899BDF1E9154BA020C0"
    },
    "cell_type" : "code",
    "source" : "object MySparkJob {\n\n    val greeting = \"Hello Spark!\"\n    \n    def main(arguments: Array[String]) = {\n        println(greeting)\n        \n        // Create your SparkContext, etc., etc.\n    }\n}",
    "outputs" : [ {
      "name" : "stdout",
      "output_type" : "stream",
      "text" : "defined object MySparkJob\n"
    }, {
      "metadata" : { },
      "data" : {
        "text/html" : ""
      },
      "output_type" : "execute_result",
      "execution_count" : 59
    } ]
  }, {
    "metadata" : {
      "id" : "378CA4822C7A461A80EAE453340AA1B9"
    },
    "cell_type" : "markdown",
    "source" : "Just as for classes, the name of the object can be anything you want. There is no `static` keyword in Scala. Instead of adding `static` methods and fields to classes as in Java, you put them in objects instead, as here.\n\n> **NOTE:** Because the Scala compiler must generate valid JVM byte code, these definitions are converted into the equivalent, Java-like static definitions in the output byte code."
  }, {
    "metadata" : {
      "id" : "5AC7D2875B4C44F299F1ECF6E6A4674B"
    },
    "cell_type" : "markdown",
    "source" : "### Case Classes\nTuples are handy for representing records and for decomposing them with pattern matching. However, it would be nice if the fields were _named_, as well as _typed_. A good use for a class, like our `IIRecord1` above, us to represent this structure and give us named fields. Let's now refine that class definition to exploit some extra, very useful features in Scala.\n\nConsider the following definition of a _case class_ that represents our final record type."
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "id" : "BFC725674989451788C183FD136D5FBC"
    },
    "cell_type" : "code",
    "source" : "case class IIRecord(\n    word: String, \n    total_count: Int = 0, \n    locations: Array[String] = Array.empty, \n    counts: Array[Int] = Array.empty) {\n\n    /** \n     * Different than our CSV output above, but see toCSV.\n     * Array.toString is useless, so format these ourselves. \n     */\n    override def toString: String = \n        s\"\"\"IIRecord($word, $total_count, $locStr, $cntStr)\"\"\"\n    \n    /** CSV-formatted string, but use [a,b,c] for the arrays */\n    def toCSV: String = \n        s\"$word,$total_count,$locStr,$cntStr\"\n        \n    /** Return a JSON-formatted string for the instance. */\n    def toJSONString: String = \n        s\"\"\"{\n        |  \"word\":        \"$word\", \n        |  \"total_count\": $total_count, \n        |  \"locations\":   ${toJSONArrayString(locations)},\n        |  \"counts\"       ${toArrayString(counts, \", \")}\n        |}\n        |\"\"\".stripMargin\n\n    private def locStr = toArrayString(locations)\n    private def cntStr = toArrayString(counts)\n\n    // \"[_]\" means we don't care what type of elements; we're just\n    // calling toString on them!\n    private def toArrayString(array: Array[_], delim: String = \",\"): String = \n        array.mkString(\"[\", delim, \"]\")  // i.e., \"[a,b,c]\"\n\n    private def toJSONArrayString(array: Array[String]): String =\n        toArrayString(array.map(quote), \", \")\n    \n    private def quote(word: String): String = \"\\\"\" + word + \"\\\"\"  \n}",
    "outputs" : [ {
      "name" : "stdout",
      "output_type" : "stream",
      "text" : "defined class IIRecord\n"
    }, {
      "metadata" : { },
      "data" : {
        "text/html" : ""
      },
      "output_type" : "execute_result",
      "execution_count" : 60
    } ]
  }, {
    "metadata" : {
      "id" : "E6F90E87F0FE4F0789FE3CBB009F2C84"
    },
    "cell_type" : "markdown",
    "source" : "I said that defining secondary constructors is not very common. In part, it's because I used a convenient feature, the ability to define default values for arguments to methods, including the primary constructor. The default values mean that I can create instances without providing all the arguments explicitly, as long as there is a default value defined, and similarly for calling methods. Consider these two examples:"
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "id" : "D933A899DBEA4CFD886EA159A598CD23"
    },
    "cell_type" : "code",
    "source" : "val hello = new IIRecord(\"hello\")\nval world = new IIRecord(\"world!\", 3, Array(\"one\", \"two\"), Array(1, 2))\n\nprintln(\"\\n`toString` output:\")\nprintln(hello)\nprintln(world)\n\nprintln(\"\\n`toJSONString` output:\")\nprintln(hello.toJSONString)\nprintln(world.toJSONString)\n\nprintln(\"\\n`toCSV` output:\")\nprintln(hello.toCSV)\nprintln(world.toCSV)",
    "outputs" : [ {
      "name" : "stdout",
      "output_type" : "stream",
      "text" : "\n`toString` output:\nIIRecord(hello, 0, [], [])\nIIRecord(world!, 3, [one,two], [1,2])\n\n`toJSONString` output:\n{\n  \"word\":        \"hello\", \n  \"total_count\": 0, \n  \"locations\":   [],\n  \"counts\"       []\n}\n\n{\n  \"word\":        \"world!\", \n  \"total_count\": 3, \n  \"locations\":   [\"one\", \"two\"],\n  \"counts\"       [1, 2]\n}\n\n\n`toCSV` output:\nhello,0,[],[]\nworld!,3,[one,two],[1,2]\nhello: IIRecord = IIRecord(hello, 0, [], [])\nworld: IIRecord = IIRecord(world!, 3, [one,two], [1,2])\n"
    }, {
      "metadata" : { },
      "data" : {
        "text/html" : ""
      },
      "output_type" : "execute_result",
      "execution_count" : 61
    } ]
  }, {
    "metadata" : {
      "id" : "2EFE1FD2D6D5447886C2AD89CF017711"
    },
    "cell_type" : "markdown",
    "source" : "I added `toJSONString` to illustrate adding _public_ methods, the default visibility, and _private_ methods to a class definition. By the way, when there are no methods or non-field variables to define, I can omit the body complete; no empty `{}` required.\n\nRecall that the `override` keyword is required when redefining `toString`."
  }, {
    "metadata" : {
      "id" : "28D18FCD76A64DD592DD8BA3970CCFD5"
    },
    "cell_type" : "markdown",
    "source" : "Okay, what about that `case` keyword? It tells the compiler to do several useful things for us, eliminating a lot of boilerplate that we would have to write for ourselves with other languages, especially Java:\n\n1. Treat each constructor argument as an immutable (`val`) private field of the instance.\n1. Generate a public reader method for the field with the same name (e.g., `word`).\n1. Generate _correct_ implementations of the `equals` and `hashCode` methods, which people often implement incorrectly, as well as a default `toString` method. You can use your own definitions by adding them explicitly to the body. We did this for `toString`, to format the arrays in a nicer way than the default `Array[_].toString` method.\n1. Generate an `object IIRecord`, i.e., with the same name. The object is called the _companion object_.\n1. Generate a \"factory\" method in the companion object that takes the same argument list and instantiates an instance.\n1. Generate helper methods in the companion object that support pattern matching.\n\nPoints 1 and 2 make each argument behave as if they are public, read-only fields of the instance, but they are actually implemented as described.\n\nPoint 3 is important for correct behavior. Case class instances are often used as keys in [Maps](http://www.scala-lang.org/api/current/index.html#scala.collection.Map) and [Sets](http://www.scala-lang.org/api/current/index.html#scala.collection.Set), Spark RDD and DataFrame methods, etc. In fact, you should _only_ use your case classes or Scala's built-in types with well-defined `hashCode` and `equals` methods (like `Int` and other number types, `String`, tuples, etc.) as keys.\n\nFor point 4, the _companion object_ is generated automatically by the compiler. It adds the \"factory\" method discussed in point 5, and methods that support pattern matching, point 6. You can explicitly define these methods and others yourself, as well as fields to hold state. The compiler will still insert these other methods. However, see <a href=\"#Ambiguities\">Ambiguities with Companion Objects</a>. The bottom line is that you shouldn't define case classes in notebooks like this with extra methods in the companion object, due to parsing ambiguities.\n\nPoint 5 means you actually rarely use `new` when creating instances. That is, the following are effectively equivalent:"
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "id" : "4CFDB66B3462418F89967C3FF58F8222"
    },
    "cell_type" : "code",
    "source" : "val hello1 = new IIRecord(\"hello1\")\nval hello2 = IIRecord(\"hello2\")",
    "outputs" : [ {
      "name" : "stdout",
      "output_type" : "stream",
      "text" : "hello1: IIRecord = IIRecord(hello1, 0, [], [])\nhello2: IIRecord = IIRecord(hello2, 0, [], [])\n"
    }, {
      "metadata" : { },
      "data" : {
        "text/html" : ""
      },
      "output_type" : "execute_result",
      "execution_count" : 62
    } ]
  }, {
    "metadata" : {
      "id" : "7472F705871D4CC38546FB8C4D416AAE"
    },
    "cell_type" : "markdown",
    "source" : "What actually happens in the second case, without `new`? The \"factory\" method is actually called `apply`. In Scala, whenever you put an argument list after any _instance_, including these `objects`, as in the `hello2` case, Scala looks for an `apply` method to call. The arguments have to match the argument list for apply (number of arguments, types of arguments, accounting for default argument values, etc.). Hence, the `hello2` declaration is really this:"
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "id" : "88DDD90C19B64C1C80C037DEEAA3E895"
    },
    "cell_type" : "code",
    "source" : "val hello2b = IIRecord.apply(\"hello2b\")",
    "outputs" : [ {
      "name" : "stdout",
      "output_type" : "stream",
      "text" : "hello2b: IIRecord = IIRecord(hello2b, 0, [], [])\n"
    }, {
      "metadata" : { },
      "data" : {
        "text/html" : ""
      },
      "output_type" : "execute_result",
      "execution_count" : 63
    } ]
  }, {
    "metadata" : {
      "id" : "8FDF18BD8DA74C0D8CABD6EA3B96584A"
    },
    "cell_type" : "markdown",
    "source" : "You can exploit this feature, too, in your other classes. We talked about word stemming above. Suppose you write a stemming library and declare an object for as the entry point. Here, I'll just do something simple; assume a trailing \"s\" means the word is a plural and remove it (a bad assumption...):"
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "id" : "E44A24511FC94B8F87974F7A3665FE7C"
    },
    "cell_type" : "code",
    "source" : "object stem {\n    def apply(word: String): String = word.replaceFirst(\"s$\", \"\") // insert real implementation!\n}\n\nprintln(stem(\"dog\"))\nprintln(stem(\"dogs\"))",
    "outputs" : [ {
      "name" : "stdout",
      "output_type" : "stream",
      "text" : "dog\ndog\ndefined object stem\n"
    }, {
      "metadata" : { },
      "data" : {
        "text/html" : ""
      },
      "output_type" : "execute_result",
      "execution_count" : 64
    } ]
  }, {
    "metadata" : {
      "id" : "AFF82895E4174B9B8840C286B55E9942"
    },
    "cell_type" : "markdown",
    "source" : "Note how it looks like I'm calling a function or method named `stem`. Scala allows object and class names to start with a lower case letter."
  }, {
    "metadata" : {
      "id" : "7F9B448BBC2F47E6821CA916459FD59C"
    },
    "cell_type" : "markdown",
    "source" : "Finally, point 6 means we can use our custom case classes in pattern matching expressions. I won't go into the methods actually implemented in the companion object and how they support pattern matching. I'll just use the \"magic\" in the following example that \"parses\" or previously-defined `hello` and `world` instances."
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "presentation" : {
        "tabs_state" : "{\n  \"tab_id\": \"#tab1592055559-0\"\n}",
        "pivot_chart_state" : "{\n  \"hiddenAttributes\": [],\n  \"menuLimit\": 200,\n  \"cols\": [],\n  \"rows\": [],\n  \"vals\": [],\n  \"exclusions\": {},\n  \"inclusions\": {},\n  \"unusedAttrsVertical\": 85,\n  \"autoSortUnusedAttrs\": false,\n  \"inclusionsInfo\": {},\n  \"aggregatorName\": \"Count\",\n  \"rendererName\": \"Table\"\n}"
      },
      "id" : "E5528BE4892B47AFBBA677D7A6E011E8"
    },
    "cell_type" : "code",
    "source" : "Seq(hello, world).map {\n    case IIRecord(word, 0, _, _) => s\"$word with no occurrences.\"\n    case IIRecord(word, cnt, locs, cnts) => \n        s\"$word occurs $cnt times: ${locs.zip(cnts).mkString(\", \")}\"\n}",
    "outputs" : [ {
      "name" : "stdout",
      "output_type" : "stream",
      "text" : "res107: Seq[String] = List(hello with no occurrences., world! occurs 3 times: (one,1), (two,2))\n"
    }, {
      "metadata" : { },
      "data" : {
        "text/html" : "<div>\n      <script data-this=\"{&quot;dataId&quot;:&quot;anon6ad02c7a3befe3b100dbd11d9d1c0208&quot;,&quot;dataInit&quot;:[{&quot;string value&quot;:&quot;hello with no occurrences.&quot;},{&quot;string value&quot;:&quot;world! occurs 3 times: (one,1), (two,2)&quot;}],&quot;genId&quot;:&quot;1592055559&quot;}\" type=\"text/x-scoped-javascript\">/*<![CDATA[*/req(['../javascripts/notebook/playground','../javascripts/notebook/magic/tabs'], \n      function(playground, _magictabs) {\n        // data ==> data-this (in observable.js's scopedEval) ==> this in JS => { dataId, dataInit, ... }\n        // this ==> scope (in observable.js's scopedEval) ==> this.parentElement ==> div.container below (toHtml)\n\n        playground.call(data,\n                        this\n                        ,\n                        {\n    \"f\": _magictabs,\n    \"o\": {}\n  }\n  \n                        \n                        \n                      );\n      }\n    );/*]]>*/</script>\n    <div>\n        <div>\n          <ul class=\"nav nav-tabs\" id=\"ul1592055559\"><li>\n                <a href=\"#tab1592055559-0\"><i class=\"fa fa-table\"/></a>\n              </li><li>\n                <a href=\"#tab1592055559-1\"><i class=\"fa fa-cubes\"/></a>\n              </li></ul>\n\n          <div class=\"tab-content\" id=\"tab1592055559\"><div class=\"tab-pane\" id=\"tab1592055559-0\">\n              <div>\n      <script data-this=\"{&quot;dataId&quot;:&quot;anonc4b28bf0f6907e7ac40608e8ed8b4dba&quot;,&quot;dataInit&quot;:[{&quot;string value&quot;:&quot;hello with no occurrences.&quot;},{&quot;string value&quot;:&quot;world! occurs 3 times: (one,1), (two,2)&quot;}],&quot;genId&quot;:&quot;960093783&quot;}\" type=\"text/x-scoped-javascript\">/*<![CDATA[*/req(['../javascripts/notebook/playground','../javascripts/notebook/magic/tableChart'], \n      function(playground, _magictableChart) {\n        // data ==> data-this (in observable.js's scopedEval) ==> this in JS => { dataId, dataInit, ... }\n        // this ==> scope (in observable.js's scopedEval) ==> this.parentElement ==> div.container below (toHtml)\n\n        playground.call(data,\n                        this\n                        ,\n                        {\n    \"f\": _magictableChart,\n    \"o\": {\"headers\":[\"string value\"],\"width\":600,\"height\":400}\n  }\n  \n                        \n                        \n                      );\n      }\n    );/*]]>*/</script>\n    <div>\n        <p data-bind=\"text: value\"><script data-this=\"{&quot;valueId&quot;:&quot;anonea424ece2d7c6104bf1933504945539c&quot;}\" type=\"text/x-scoped-javascript\">/*<![CDATA[*/\nreq(\n['observable', 'knockout'],\nfunction (O, ko) {\n  ko.applyBindings({\n      value: O.makeObservable(valueId)\n    },\n    this\n  );\n});\n        /*]]>*/</script></p> <span style=\"color:red\"><p data-bind=\"text: value\"><script data-this=\"{&quot;valueId&quot;:&quot;anon3bb4b74d60738ec648dc5e81f2099d44&quot;}\" type=\"text/x-scoped-javascript\">/*<![CDATA[*/\nreq(\n['observable', 'knockout'],\nfunction (O, ko) {\n  ko.applyBindings({\n      value: O.makeObservable(valueId)\n    },\n    this\n  );\n});\n        /*]]>*/</script></p></span>\n        <div>\n        </div>\n      </div></div>\n              </div><div class=\"tab-pane\" id=\"tab1592055559-1\">\n              <div>\n      <script data-this=\"{&quot;dataId&quot;:&quot;anon2c404c64186341d47fad114e62b16acf&quot;,&quot;dataInit&quot;:[{&quot;string value&quot;:&quot;hello with no occurrences.&quot;},{&quot;string value&quot;:&quot;world! occurs 3 times: (one,1), (two,2)&quot;}],&quot;genId&quot;:&quot;1803090870&quot;}\" type=\"text/x-scoped-javascript\">/*<![CDATA[*/req(['../javascripts/notebook/playground','../javascripts/notebook/magic/pivotChart'], \n      function(playground, _magicpivotChart) {\n        // data ==> data-this (in observable.js's scopedEval) ==> this in JS => { dataId, dataInit, ... }\n        // this ==> scope (in observable.js's scopedEval) ==> this.parentElement ==> div.container below (toHtml)\n\n        playground.call(data,\n                        this\n                        ,\n                        {\n    \"f\": _magicpivotChart,\n    \"o\": {\"width\":600,\"height\":400,\"derivedAttributes\":{},\"extraOptions\":{}}\n  }\n  \n                        \n                        \n                      );\n      }\n    );/*]]>*/</script>\n    <div>\n        <p data-bind=\"text: value\"><script data-this=\"{&quot;valueId&quot;:&quot;anonc77ef56701d1cc8a676dc77b74a83569&quot;}\" type=\"text/x-scoped-javascript\">/*<![CDATA[*/\nreq(\n['observable', 'knockout'],\nfunction (O, ko) {\n  ko.applyBindings({\n      value: O.makeObservable(valueId)\n    },\n    this\n  );\n});\n        /*]]>*/</script></p> <span style=\"color:red\"><p data-bind=\"text: value\"><script data-this=\"{&quot;valueId&quot;:&quot;anona6bb14014c713914f9fe4009e7d8773c&quot;}\" type=\"text/x-scoped-javascript\">/*<![CDATA[*/\nreq(\n['observable', 'knockout'],\nfunction (O, ko) {\n  ko.applyBindings({\n      value: O.makeObservable(valueId)\n    },\n    this\n  );\n});\n        /*]]>*/</script></p></span>\n        <div>\n        </div>\n      </div></div>\n              </div></div>\n        </div>\n      </div></div>"
      },
      "output_type" : "execute_result",
      "execution_count" : 65
    } ]
  }, {
    "metadata" : {
      "id" : "4FF0B17F9FDC430384E40A416C35D04E"
    },
    "cell_type" : "markdown",
    "source" : "The first case clause ignores the locations and counts, because I know they will be empty arrays if the total count is 0! \n\nThe second case clause uses the `zip` method to put the locations and counts back together. Recall we used `unzip` to create the separate collections."
  }, {
    "metadata" : {
      "id" : "B6FAD3997BF245C8AC6EDD4AE85DE15D"
    },
    "cell_type" : "markdown",
    "source" : "## Datasets and DataFrames\nWe've mostly used Spark's RDD API, where it's common to use case classes to represent the \"schema\" of records when working with RDDs, but also with a new type, [Dataset[T]](http://spark.apache.org/docs/latest/api/scala/index.html#org.apache.spark.sql.Dataset), analogous to `RDD[T]`, where the `T` represents the type of records.\n\nA problem with [DataFrames](http://spark.apache.org/docs/latest/api/scala/index.html#org.apache.spark.sql.DataFrame) is the fact that the fields are untyped until you try to access them. `Datasets` restore the type safety of `RDDs` by using a case class as the definition of the schema. \n\n`Datasets` were introduced in Spark 1.6.0, but they are somewhat incomplete in the 1.6.X releases. In Spark 2.0.0, `Dataset` becomes the \"parent\" class of `DataFrame`. This means that you'll be encouraged to use the greater type safety of `Dataset`, but you can still use `DataFrame` if you want. Now, `DataFrame` will be the equivalent of `Dataset[Row]`, where [Row](http://spark.apache.org/docs/latest/api/scala/index.html#org.apache.spark.sql.Row) is the loosely-typed representation of the row and its columns.\n\nIn Spark 1.6.2, it's somewhat awkward to convert between `DataFrames` and `Dataset`, but this is improved in Spark 2.0."
  }, {
    "metadata" : {
      "id" : "DF36806F348A4FC0B7EA0E17824ACFCC"
    },
    "cell_type" : "markdown",
    "source" : "## More Scala\nWe've covered a lot already in this notebook, focusing on the first things you need to know about Scala. This long section discusses additional details about Scala that you'll encounter relatively quickly. \n\nAt this point, I suggest you create a new notebook and play with Spark using what you've learned so far, then come back to this section if you run into something you don't understand or when you're ready to learn more Scala."
  }, {
    "metadata" : {
      "id" : "0B4C288179C7414D8DE58D87168D6B35"
    },
    "cell_type" : "markdown",
    "source" : "### Importing Everything in a Package\nIn Java, `import foo.bar.*;` means import everything in the `bar` package.\n\nIn Scala, `*` is actually a legal method name; think of defining multiplication for custom numeric types, like `Matrix`. Hence, this import statement in Scala would be ambigious. Therefore, Scala uses `_` instead of `*`, `import foo.bar._` (with the semicolon inferred)."
  }, {
    "metadata" : {
      "id" : "8D557ECC0A1E47E4B58E4D2D8B9B0B29"
    },
    "cell_type" : "markdown",
    "source" : "Incidentally, what would that `*` method definition look like? Something like this:\n\n```scala\ncase class Matrix(rows: Array[Array[Double]]) {  // Each row is an Array[Double]\n\n    /** Multiple this matrix by another. */\n    def *(other: Matrix): Matrix = ...\n    \n    /** Add this matrix by another. */\n    def +(other: Matrix): Matrix = ...\n    \n    ...\n}\n\nval row1: Array[Array[Double]] = ...\nval row2: Array[Array[Double]] = ...\nval m1 = Matrix(rows1)\nval m2 = Matrix(rows2)\nval m1_times_m2 = m1 * m2\nval m1_plus_m2 = m1 + m2\n```"
  }, {
    "metadata" : {
      "id" : "D09A3AE2C3C3408F85322926C1AE71C7"
    },
    "cell_type" : "markdown",
    "source" : "### Operator Syntax\n\nWait!! What's this `m1 * m2` stuff?? Shouldn't it be `m1.*(m2)`. It would be really convenient to use \"operator syntax\", more precisely called _infix operator notation_ for many methods like `*` and `+` here. The Scala parser supports this with a simple relaxation of the rules; when a method takes a single argument, you can omit the period `.` and parentheses `(...)`. Hence the following really is equivalent:\n\n```scala\nval m1_times_m2 = m1.*(m2)\nval m1_times_m2 = m1 * m2\n```\n\nThis convenience can lead to confusing code, especially for beginners to Scala, so use it cautiously."
  }, {
    "metadata" : {
      "id" : "B7AF61B1BFC644BB8A2C39BBAB0AA04B"
    },
    "cell_type" : "markdown",
    "source" : "### Traits\n_Traits_ are similar to Java 8 _interfaces_, used to define abstractions, but with the ability to provide \"default\" implementations of the methods declared. Unlike Java 8 interfaces, traits can also have fields representing \"state\" information about instances. There is a blury line between traits and _abstract classes_, again where some member methods or fields are not defined. In both cases, a subtype of a trait and/or an abstract class must define any undefined members if you want to construct instances of it.\n\nSo, why have both traits and abstract classes? It's because Java only allows _single inheritance_; there can be only one _parent_ type, which is normally where you would use an abstract class, but Scala lets you \"mix in\" one or more additional traits (or use a trait as the parent class - yes, confusing). A great example \"mix in\" trait is one that implements logging. Any \"service\" type can mix in the logging trait to get \"instant\" access to this reusable functionality. Schematically, it looks like the following:\n\n```scala\n// Assume severity `Level` and `Logger` types defined elsewhere...\ntrait Logging {\n\n    def log(level: Level, message: String): Unit = logger.log(level, message)\n    \n    private logger: Logger = ...\n}\n\nabstract class Service {\n    def run(): Unit   // No body, so abstract!\n}\n\nclass MyService extends Service with Logging {\n    def run(): Unit = {\n        log(INFO, \"Staring MyService...\")\n        ...\n        log(INFO, \"Finished MyService\")\n    }\n}\n```\n\n`Unit` is Scala's equivalent to Java's `void`. It actually is a true type with a single return value, unlike `void`, but we use it in the same sense of \"nothing useful will be returned\"."
  }, {
    "metadata" : {
      "id" : "F4F9E4DFF1914C1A8CF2B359BC3A7142"
    },
    "cell_type" : "markdown",
    "source" : "### Ranges\nWhat if you want some numbers between a start and end value? Use a [Range](http://www.scala-lang.org/api/current/index.html#scala.collection.immutable.Range), which has a nice literal syntax, e.g., `1 until 100`, `2 to 200 by 3`. \n\nThe `Range` always includes the lower bound. Using `to` in a `Range` makes it _inclusive_ at the upper bound. Using `until` makes it _exclusive_ at the upper bound. Use `by` to specify a delta, which defaults to `1`."
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "presentation" : {
        "tabs_state" : "{\n  \"tab_id\": \"#tab197589351-0\"\n}",
        "pivot_chart_state" : "{\n  \"hiddenAttributes\": [],\n  \"menuLimit\": 200,\n  \"cols\": [],\n  \"rows\": [],\n  \"vals\": [],\n  \"exclusions\": {},\n  \"inclusions\": {},\n  \"unusedAttrsVertical\": 85,\n  \"autoSortUnusedAttrs\": false,\n  \"inclusionsInfo\": {},\n  \"aggregatorName\": \"Count\",\n  \"rendererName\": \"Table\"\n}"
      },
      "id" : "4094E87E9CBF4B7AB7813A84B31C3512"
    },
    "cell_type" : "code",
    "source" : "1 until 10",
    "outputs" : [ {
      "name" : "stdout",
      "output_type" : "stream",
      "text" : "res116: scala.collection.immutable.Range = Range(1, 2, 3, 4, 5, 6, 7, 8, 9)\n"
    }, {
      "metadata" : { },
      "data" : {
        "text/html" : "<div>\n      <script data-this=\"{&quot;dataId&quot;:&quot;anonc4c5de7dd7c6eb7ffc90536ad41913e5&quot;,&quot;dataInit&quot;:[{&quot;_1&quot;:0,&quot;_2&quot;:1},{&quot;_1&quot;:1,&quot;_2&quot;:2},{&quot;_1&quot;:2,&quot;_2&quot;:3},{&quot;_1&quot;:3,&quot;_2&quot;:4},{&quot;_1&quot;:4,&quot;_2&quot;:5},{&quot;_1&quot;:5,&quot;_2&quot;:6},{&quot;_1&quot;:6,&quot;_2&quot;:7},{&quot;_1&quot;:7,&quot;_2&quot;:8},{&quot;_1&quot;:8,&quot;_2&quot;:9}],&quot;genId&quot;:&quot;197589351&quot;}\" type=\"text/x-scoped-javascript\">/*<![CDATA[*/req(['../javascripts/notebook/playground','../javascripts/notebook/magic/tabs'], \n      function(playground, _magictabs) {\n        // data ==> data-this (in observable.js's scopedEval) ==> this in JS => { dataId, dataInit, ... }\n        // this ==> scope (in observable.js's scopedEval) ==> this.parentElement ==> div.container below (toHtml)\n\n        playground.call(data,\n                        this\n                        ,\n                        {\n    \"f\": _magictabs,\n    \"o\": {}\n  }\n  \n                        \n                        \n                      );\n      }\n    );/*]]>*/</script>\n    <div>\n        <div>\n          <ul class=\"nav nav-tabs\" id=\"ul197589351\"><li>\n                <a href=\"#tab197589351-0\"><i class=\"fa fa-table\"/></a>\n              </li><li>\n                <a href=\"#tab197589351-1\"><i class=\"fa fa-dot-circle-o\"/></a>\n              </li><li>\n                <a href=\"#tab197589351-2\"><i class=\"fa fa-line-chart\"/></a>\n              </li><li>\n                <a href=\"#tab197589351-3\"><i class=\"fa fa-bar-chart\"/></a>\n              </li><li>\n                <a href=\"#tab197589351-4\"><i class=\"fa fa-cubes\"/></a>\n              </li></ul>\n\n          <div class=\"tab-content\" id=\"tab197589351\"><div class=\"tab-pane\" id=\"tab197589351-0\">\n              <div>\n      <script data-this=\"{&quot;dataId&quot;:&quot;anon4d5ab408a33d2fb4dd0ecb3461516aa3&quot;,&quot;dataInit&quot;:[{&quot;_1&quot;:0,&quot;_2&quot;:1},{&quot;_1&quot;:1,&quot;_2&quot;:2},{&quot;_1&quot;:2,&quot;_2&quot;:3},{&quot;_1&quot;:3,&quot;_2&quot;:4},{&quot;_1&quot;:4,&quot;_2&quot;:5},{&quot;_1&quot;:5,&quot;_2&quot;:6},{&quot;_1&quot;:6,&quot;_2&quot;:7},{&quot;_1&quot;:7,&quot;_2&quot;:8},{&quot;_1&quot;:8,&quot;_2&quot;:9}],&quot;genId&quot;:&quot;1449420674&quot;}\" type=\"text/x-scoped-javascript\">/*<![CDATA[*/req(['../javascripts/notebook/playground','../javascripts/notebook/magic/tableChart'], \n      function(playground, _magictableChart) {\n        // data ==> data-this (in observable.js's scopedEval) ==> this in JS => { dataId, dataInit, ... }\n        // this ==> scope (in observable.js's scopedEval) ==> this.parentElement ==> div.container below (toHtml)\n\n        playground.call(data,\n                        this\n                        ,\n                        {\n    \"f\": _magictableChart,\n    \"o\": {\"headers\":[\"_1\",\"_2\"],\"width\":600,\"height\":400}\n  }\n  \n                        \n                        \n                      );\n      }\n    );/*]]>*/</script>\n    <div>\n        <p data-bind=\"text: value\"><script data-this=\"{&quot;valueId&quot;:&quot;anon9798229a0b1ea72f73fa0172e8e5b4fa&quot;}\" type=\"text/x-scoped-javascript\">/*<![CDATA[*/\nreq(\n['observable', 'knockout'],\nfunction (O, ko) {\n  ko.applyBindings({\n      value: O.makeObservable(valueId)\n    },\n    this\n  );\n});\n        /*]]>*/</script></p> <span style=\"color:red\"><p data-bind=\"text: value\"><script data-this=\"{&quot;valueId&quot;:&quot;anon98c588608b5b6d1684a9de985ff93640&quot;}\" type=\"text/x-scoped-javascript\">/*<![CDATA[*/\nreq(\n['observable', 'knockout'],\nfunction (O, ko) {\n  ko.applyBindings({\n      value: O.makeObservable(valueId)\n    },\n    this\n  );\n});\n        /*]]>*/</script></p></span>\n        <div>\n        </div>\n      </div></div>\n              </div><div class=\"tab-pane\" id=\"tab197589351-1\">\n              <div>\n      <script data-this=\"{&quot;dataId&quot;:&quot;anona90e332293e4e1cafc67e7c4797e63c7&quot;,&quot;dataInit&quot;:[{&quot;_1&quot;:0,&quot;_2&quot;:1},{&quot;_1&quot;:1,&quot;_2&quot;:2},{&quot;_1&quot;:2,&quot;_2&quot;:3},{&quot;_1&quot;:3,&quot;_2&quot;:4},{&quot;_1&quot;:4,&quot;_2&quot;:5},{&quot;_1&quot;:5,&quot;_2&quot;:6},{&quot;_1&quot;:6,&quot;_2&quot;:7},{&quot;_1&quot;:7,&quot;_2&quot;:8},{&quot;_1&quot;:8,&quot;_2&quot;:9}],&quot;genId&quot;:&quot;201552232&quot;}\" type=\"text/x-scoped-javascript\">/*<![CDATA[*/req(['../javascripts/notebook/playground','../javascripts/notebook/magic/scatterChart'], \n      function(playground, _magicscatterChart) {\n        // data ==> data-this (in observable.js's scopedEval) ==> this in JS => { dataId, dataInit, ... }\n        // this ==> scope (in observable.js's scopedEval) ==> this.parentElement ==> div.container below (toHtml)\n\n        playground.call(data,\n                        this\n                        ,\n                        {\n    \"f\": _magicscatterChart,\n    \"o\": {\"x\":\"_1\",\"y\":\"_2\",\"width\":600,\"height\":400}\n  }\n  \n                        \n                        \n                      );\n      }\n    );/*]]>*/</script>\n    <div>\n        <p data-bind=\"text: value\"><script data-this=\"{&quot;valueId&quot;:&quot;anon532e817a4cc166acb19ad77a6eccb2fa&quot;}\" type=\"text/x-scoped-javascript\">/*<![CDATA[*/\nreq(\n['observable', 'knockout'],\nfunction (O, ko) {\n  ko.applyBindings({\n      value: O.makeObservable(valueId)\n    },\n    this\n  );\n});\n        /*]]>*/</script></p> <span style=\"color:red\"><p data-bind=\"text: value\"><script data-this=\"{&quot;valueId&quot;:&quot;anonf4e36a387e4857591c516fba4eeec97c&quot;}\" type=\"text/x-scoped-javascript\">/*<![CDATA[*/\nreq(\n['observable', 'knockout'],\nfunction (O, ko) {\n  ko.applyBindings({\n      value: O.makeObservable(valueId)\n    },\n    this\n  );\n});\n        /*]]>*/</script></p></span>\n        <div>\n        </div>\n      </div></div>\n              </div><div class=\"tab-pane\" id=\"tab197589351-2\">\n              <div>\n      <script data-this=\"{&quot;dataId&quot;:&quot;anon3648941eb23a09523e92d8d28e61f598&quot;,&quot;dataInit&quot;:[{&quot;_1&quot;:0,&quot;_2&quot;:1},{&quot;_1&quot;:1,&quot;_2&quot;:2},{&quot;_1&quot;:2,&quot;_2&quot;:3},{&quot;_1&quot;:3,&quot;_2&quot;:4},{&quot;_1&quot;:4,&quot;_2&quot;:5},{&quot;_1&quot;:5,&quot;_2&quot;:6},{&quot;_1&quot;:6,&quot;_2&quot;:7},{&quot;_1&quot;:7,&quot;_2&quot;:8},{&quot;_1&quot;:8,&quot;_2&quot;:9}],&quot;genId&quot;:&quot;1286892345&quot;}\" type=\"text/x-scoped-javascript\">/*<![CDATA[*/req(['../javascripts/notebook/playground','../javascripts/notebook/magic/lineChart'], \n      function(playground, _magiclineChart) {\n        // data ==> data-this (in observable.js's scopedEval) ==> this in JS => { dataId, dataInit, ... }\n        // this ==> scope (in observable.js's scopedEval) ==> this.parentElement ==> div.container below (toHtml)\n\n        playground.call(data,\n                        this\n                        ,\n                        {\n    \"f\": _magiclineChart,\n    \"o\": {\"x\":\"_1\",\"y\":\"_2\",\"width\":600,\"height\":400}\n  }\n  \n                        \n                        \n                      );\n      }\n    );/*]]>*/</script>\n    <div>\n        <p data-bind=\"text: value\"><script data-this=\"{&quot;valueId&quot;:&quot;anonb43f2e1e778694f81f4ee34f46ba11fe&quot;}\" type=\"text/x-scoped-javascript\">/*<![CDATA[*/\nreq(\n['observable', 'knockout'],\nfunction (O, ko) {\n  ko.applyBindings({\n      value: O.makeObservable(valueId)\n    },\n    this\n  );\n});\n        /*]]>*/</script></p> <span style=\"color:red\"><p data-bind=\"text: value\"><script data-this=\"{&quot;valueId&quot;:&quot;anonee73ad0cf76d6671c05d4853bfdc8321&quot;}\" type=\"text/x-scoped-javascript\">/*<![CDATA[*/\nreq(\n['observable', 'knockout'],\nfunction (O, ko) {\n  ko.applyBindings({\n      value: O.makeObservable(valueId)\n    },\n    this\n  );\n});\n        /*]]>*/</script></p></span>\n        <div>\n        </div>\n      </div></div>\n              </div><div class=\"tab-pane\" id=\"tab197589351-3\">\n              <div>\n      <script data-this=\"{&quot;dataId&quot;:&quot;anonbda9e26db8868cd3b27b74b56f96f886&quot;,&quot;dataInit&quot;:[{&quot;_1&quot;:0,&quot;_2&quot;:1},{&quot;_1&quot;:1,&quot;_2&quot;:2},{&quot;_1&quot;:2,&quot;_2&quot;:3},{&quot;_1&quot;:3,&quot;_2&quot;:4},{&quot;_1&quot;:4,&quot;_2&quot;:5},{&quot;_1&quot;:5,&quot;_2&quot;:6},{&quot;_1&quot;:6,&quot;_2&quot;:7},{&quot;_1&quot;:7,&quot;_2&quot;:8},{&quot;_1&quot;:8,&quot;_2&quot;:9}],&quot;genId&quot;:&quot;1206377489&quot;}\" type=\"text/x-scoped-javascript\">/*<![CDATA[*/req(['../javascripts/notebook/playground','../javascripts/notebook/magic/barChart'], \n      function(playground, _magicbarChart) {\n        // data ==> data-this (in observable.js's scopedEval) ==> this in JS => { dataId, dataInit, ... }\n        // this ==> scope (in observable.js's scopedEval) ==> this.parentElement ==> div.container below (toHtml)\n\n        playground.call(data,\n                        this\n                        ,\n                        {\n    \"f\": _magicbarChart,\n    \"o\": {\"x\":\"_1\",\"y\":\"_2\",\"width\":600,\"height\":400}\n  }\n  \n                        \n                        \n                      );\n      }\n    );/*]]>*/</script>\n    <div>\n        <p data-bind=\"text: value\"><script data-this=\"{&quot;valueId&quot;:&quot;anon2c148ce2549f0f26bd99f4b8c329040f&quot;}\" type=\"text/x-scoped-javascript\">/*<![CDATA[*/\nreq(\n['observable', 'knockout'],\nfunction (O, ko) {\n  ko.applyBindings({\n      value: O.makeObservable(valueId)\n    },\n    this\n  );\n});\n        /*]]>*/</script></p> <span style=\"color:red\"><p data-bind=\"text: value\"><script data-this=\"{&quot;valueId&quot;:&quot;anonb9fbc64db738a362b32a32a82f9c9e88&quot;}\" type=\"text/x-scoped-javascript\">/*<![CDATA[*/\nreq(\n['observable', 'knockout'],\nfunction (O, ko) {\n  ko.applyBindings({\n      value: O.makeObservable(valueId)\n    },\n    this\n  );\n});\n        /*]]>*/</script></p></span>\n        <div>\n        </div>\n      </div></div>\n              </div><div class=\"tab-pane\" id=\"tab197589351-4\">\n              <div>\n      <script data-this=\"{&quot;dataId&quot;:&quot;anon478d6ebe1340d46d6b421cf2397d3723&quot;,&quot;dataInit&quot;:[{&quot;_1&quot;:0,&quot;_2&quot;:1},{&quot;_1&quot;:1,&quot;_2&quot;:2},{&quot;_1&quot;:2,&quot;_2&quot;:3},{&quot;_1&quot;:3,&quot;_2&quot;:4},{&quot;_1&quot;:4,&quot;_2&quot;:5},{&quot;_1&quot;:5,&quot;_2&quot;:6},{&quot;_1&quot;:6,&quot;_2&quot;:7},{&quot;_1&quot;:7,&quot;_2&quot;:8},{&quot;_1&quot;:8,&quot;_2&quot;:9}],&quot;genId&quot;:&quot;1830691361&quot;}\" type=\"text/x-scoped-javascript\">/*<![CDATA[*/req(['../javascripts/notebook/playground','../javascripts/notebook/magic/pivotChart'], \n      function(playground, _magicpivotChart) {\n        // data ==> data-this (in observable.js's scopedEval) ==> this in JS => { dataId, dataInit, ... }\n        // this ==> scope (in observable.js's scopedEval) ==> this.parentElement ==> div.container below (toHtml)\n\n        playground.call(data,\n                        this\n                        ,\n                        {\n    \"f\": _magicpivotChart,\n    \"o\": {\"width\":600,\"height\":400,\"derivedAttributes\":{},\"extraOptions\":{}}\n  }\n  \n                        \n                        \n                      );\n      }\n    );/*]]>*/</script>\n    <div>\n        <p data-bind=\"text: value\"><script data-this=\"{&quot;valueId&quot;:&quot;anon084016d8da8a16372c3277804f8a5242&quot;}\" type=\"text/x-scoped-javascript\">/*<![CDATA[*/\nreq(\n['observable', 'knockout'],\nfunction (O, ko) {\n  ko.applyBindings({\n      value: O.makeObservable(valueId)\n    },\n    this\n  );\n});\n        /*]]>*/</script></p> <span style=\"color:red\"><p data-bind=\"text: value\"><script data-this=\"{&quot;valueId&quot;:&quot;anon6e326e2d2d6d7754a8f84eebea8b3585&quot;}\" type=\"text/x-scoped-javascript\">/*<![CDATA[*/\nreq(\n['observable', 'knockout'],\nfunction (O, ko) {\n  ko.applyBindings({\n      value: O.makeObservable(valueId)\n    },\n    this\n  );\n});\n        /*]]>*/</script></p></span>\n        <div>\n        </div>\n      </div></div>\n              </div></div>\n        </div>\n      </div></div>"
      },
      "output_type" : "execute_result",
      "execution_count" : 70
    } ]
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "presentation" : {
        "tabs_state" : "{\n  \"tab_id\": \"#tab608362284-0\"\n}",
        "pivot_chart_state" : "{\n  \"hiddenAttributes\": [],\n  \"menuLimit\": 200,\n  \"cols\": [],\n  \"rows\": [],\n  \"vals\": [],\n  \"exclusions\": {},\n  \"inclusions\": {},\n  \"unusedAttrsVertical\": 85,\n  \"autoSortUnusedAttrs\": false,\n  \"inclusionsInfo\": {},\n  \"aggregatorName\": \"Count\",\n  \"rendererName\": \"Table\"\n}"
      },
      "id" : "DABC04E31BF74B9FAD7630F87CF197F3"
    },
    "cell_type" : "code",
    "source" : "1 to 10",
    "outputs" : [ {
      "name" : "stdout",
      "output_type" : "stream",
      "text" : "res118: scala.collection.immutable.Range.Inclusive = Range(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n"
    }, {
      "metadata" : { },
      "data" : {
        "text/html" : "<div>\n      <script data-this=\"{&quot;dataId&quot;:&quot;anone4494b5500b506f8bdfff5a646c11be6&quot;,&quot;dataInit&quot;:[{&quot;_1&quot;:0,&quot;_2&quot;:1},{&quot;_1&quot;:1,&quot;_2&quot;:2},{&quot;_1&quot;:2,&quot;_2&quot;:3},{&quot;_1&quot;:3,&quot;_2&quot;:4},{&quot;_1&quot;:4,&quot;_2&quot;:5},{&quot;_1&quot;:5,&quot;_2&quot;:6},{&quot;_1&quot;:6,&quot;_2&quot;:7},{&quot;_1&quot;:7,&quot;_2&quot;:8},{&quot;_1&quot;:8,&quot;_2&quot;:9},{&quot;_1&quot;:9,&quot;_2&quot;:10}],&quot;genId&quot;:&quot;608362284&quot;}\" type=\"text/x-scoped-javascript\">/*<![CDATA[*/req(['../javascripts/notebook/playground','../javascripts/notebook/magic/tabs'], \n      function(playground, _magictabs) {\n        // data ==> data-this (in observable.js's scopedEval) ==> this in JS => { dataId, dataInit, ... }\n        // this ==> scope (in observable.js's scopedEval) ==> this.parentElement ==> div.container below (toHtml)\n\n        playground.call(data,\n                        this\n                        ,\n                        {\n    \"f\": _magictabs,\n    \"o\": {}\n  }\n  \n                        \n                        \n                      );\n      }\n    );/*]]>*/</script>\n    <div>\n        <div>\n          <ul class=\"nav nav-tabs\" id=\"ul608362284\"><li>\n                <a href=\"#tab608362284-0\"><i class=\"fa fa-table\"/></a>\n              </li><li>\n                <a href=\"#tab608362284-1\"><i class=\"fa fa-dot-circle-o\"/></a>\n              </li><li>\n                <a href=\"#tab608362284-2\"><i class=\"fa fa-line-chart\"/></a>\n              </li><li>\n                <a href=\"#tab608362284-3\"><i class=\"fa fa-bar-chart\"/></a>\n              </li><li>\n                <a href=\"#tab608362284-4\"><i class=\"fa fa-cubes\"/></a>\n              </li></ul>\n\n          <div class=\"tab-content\" id=\"tab608362284\"><div class=\"tab-pane\" id=\"tab608362284-0\">\n              <div>\n      <script data-this=\"{&quot;dataId&quot;:&quot;anon25666aa76b7fbfddd62479bb772a2355&quot;,&quot;dataInit&quot;:[{&quot;_1&quot;:0,&quot;_2&quot;:1},{&quot;_1&quot;:1,&quot;_2&quot;:2},{&quot;_1&quot;:2,&quot;_2&quot;:3},{&quot;_1&quot;:3,&quot;_2&quot;:4},{&quot;_1&quot;:4,&quot;_2&quot;:5},{&quot;_1&quot;:5,&quot;_2&quot;:6},{&quot;_1&quot;:6,&quot;_2&quot;:7},{&quot;_1&quot;:7,&quot;_2&quot;:8},{&quot;_1&quot;:8,&quot;_2&quot;:9},{&quot;_1&quot;:9,&quot;_2&quot;:10}],&quot;genId&quot;:&quot;1491013093&quot;}\" type=\"text/x-scoped-javascript\">/*<![CDATA[*/req(['../javascripts/notebook/playground','../javascripts/notebook/magic/tableChart'], \n      function(playground, _magictableChart) {\n        // data ==> data-this (in observable.js's scopedEval) ==> this in JS => { dataId, dataInit, ... }\n        // this ==> scope (in observable.js's scopedEval) ==> this.parentElement ==> div.container below (toHtml)\n\n        playground.call(data,\n                        this\n                        ,\n                        {\n    \"f\": _magictableChart,\n    \"o\": {\"headers\":[\"_1\",\"_2\"],\"width\":600,\"height\":400}\n  }\n  \n                        \n                        \n                      );\n      }\n    );/*]]>*/</script>\n    <div>\n        <p data-bind=\"text: value\"><script data-this=\"{&quot;valueId&quot;:&quot;anon8e897fd105201dc2fc25526f0f9984c2&quot;}\" type=\"text/x-scoped-javascript\">/*<![CDATA[*/\nreq(\n['observable', 'knockout'],\nfunction (O, ko) {\n  ko.applyBindings({\n      value: O.makeObservable(valueId)\n    },\n    this\n  );\n});\n        /*]]>*/</script></p> <span style=\"color:red\"><p data-bind=\"text: value\"><script data-this=\"{&quot;valueId&quot;:&quot;anon63a5a2c9be51c8ea15c4f4a9a12147ef&quot;}\" type=\"text/x-scoped-javascript\">/*<![CDATA[*/\nreq(\n['observable', 'knockout'],\nfunction (O, ko) {\n  ko.applyBindings({\n      value: O.makeObservable(valueId)\n    },\n    this\n  );\n});\n        /*]]>*/</script></p></span>\n        <div>\n        </div>\n      </div></div>\n              </div><div class=\"tab-pane\" id=\"tab608362284-1\">\n              <div>\n      <script data-this=\"{&quot;dataId&quot;:&quot;anon685bb8c3ce82cbeba189c3b608deccc5&quot;,&quot;dataInit&quot;:[{&quot;_1&quot;:0,&quot;_2&quot;:1},{&quot;_1&quot;:1,&quot;_2&quot;:2},{&quot;_1&quot;:2,&quot;_2&quot;:3},{&quot;_1&quot;:3,&quot;_2&quot;:4},{&quot;_1&quot;:4,&quot;_2&quot;:5},{&quot;_1&quot;:5,&quot;_2&quot;:6},{&quot;_1&quot;:6,&quot;_2&quot;:7},{&quot;_1&quot;:7,&quot;_2&quot;:8},{&quot;_1&quot;:8,&quot;_2&quot;:9},{&quot;_1&quot;:9,&quot;_2&quot;:10}],&quot;genId&quot;:&quot;1254262396&quot;}\" type=\"text/x-scoped-javascript\">/*<![CDATA[*/req(['../javascripts/notebook/playground','../javascripts/notebook/magic/scatterChart'], \n      function(playground, _magicscatterChart) {\n        // data ==> data-this (in observable.js's scopedEval) ==> this in JS => { dataId, dataInit, ... }\n        // this ==> scope (in observable.js's scopedEval) ==> this.parentElement ==> div.container below (toHtml)\n\n        playground.call(data,\n                        this\n                        ,\n                        {\n    \"f\": _magicscatterChart,\n    \"o\": {\"x\":\"_1\",\"y\":\"_2\",\"width\":600,\"height\":400}\n  }\n  \n                        \n                        \n                      );\n      }\n    );/*]]>*/</script>\n    <div>\n        <p data-bind=\"text: value\"><script data-this=\"{&quot;valueId&quot;:&quot;anon9add76b899454f82f13062a77d59d96f&quot;}\" type=\"text/x-scoped-javascript\">/*<![CDATA[*/\nreq(\n['observable', 'knockout'],\nfunction (O, ko) {\n  ko.applyBindings({\n      value: O.makeObservable(valueId)\n    },\n    this\n  );\n});\n        /*]]>*/</script></p> <span style=\"color:red\"><p data-bind=\"text: value\"><script data-this=\"{&quot;valueId&quot;:&quot;anon9a93c24f336ff0ecf1ead714523f8a99&quot;}\" type=\"text/x-scoped-javascript\">/*<![CDATA[*/\nreq(\n['observable', 'knockout'],\nfunction (O, ko) {\n  ko.applyBindings({\n      value: O.makeObservable(valueId)\n    },\n    this\n  );\n});\n        /*]]>*/</script></p></span>\n        <div>\n        </div>\n      </div></div>\n              </div><div class=\"tab-pane\" id=\"tab608362284-2\">\n              <div>\n      <script data-this=\"{&quot;dataId&quot;:&quot;anon39c078caabba2df3e7045730ce114e40&quot;,&quot;dataInit&quot;:[{&quot;_1&quot;:0,&quot;_2&quot;:1},{&quot;_1&quot;:1,&quot;_2&quot;:2},{&quot;_1&quot;:2,&quot;_2&quot;:3},{&quot;_1&quot;:3,&quot;_2&quot;:4},{&quot;_1&quot;:4,&quot;_2&quot;:5},{&quot;_1&quot;:5,&quot;_2&quot;:6},{&quot;_1&quot;:6,&quot;_2&quot;:7},{&quot;_1&quot;:7,&quot;_2&quot;:8},{&quot;_1&quot;:8,&quot;_2&quot;:9},{&quot;_1&quot;:9,&quot;_2&quot;:10}],&quot;genId&quot;:&quot;1946257210&quot;}\" type=\"text/x-scoped-javascript\">/*<![CDATA[*/req(['../javascripts/notebook/playground','../javascripts/notebook/magic/lineChart'], \n      function(playground, _magiclineChart) {\n        // data ==> data-this (in observable.js's scopedEval) ==> this in JS => { dataId, dataInit, ... }\n        // this ==> scope (in observable.js's scopedEval) ==> this.parentElement ==> div.container below (toHtml)\n\n        playground.call(data,\n                        this\n                        ,\n                        {\n    \"f\": _magiclineChart,\n    \"o\": {\"x\":\"_1\",\"y\":\"_2\",\"width\":600,\"height\":400}\n  }\n  \n                        \n                        \n                      );\n      }\n    );/*]]>*/</script>\n    <div>\n        <p data-bind=\"text: value\"><script data-this=\"{&quot;valueId&quot;:&quot;anonb5f08b29f215c1bf0d4a8566f4dbee8f&quot;}\" type=\"text/x-scoped-javascript\">/*<![CDATA[*/\nreq(\n['observable', 'knockout'],\nfunction (O, ko) {\n  ko.applyBindings({\n      value: O.makeObservable(valueId)\n    },\n    this\n  );\n});\n        /*]]>*/</script></p> <span style=\"color:red\"><p data-bind=\"text: value\"><script data-this=\"{&quot;valueId&quot;:&quot;anond22e18d2c27d4b358c16d014e5977a35&quot;}\" type=\"text/x-scoped-javascript\">/*<![CDATA[*/\nreq(\n['observable', 'knockout'],\nfunction (O, ko) {\n  ko.applyBindings({\n      value: O.makeObservable(valueId)\n    },\n    this\n  );\n});\n        /*]]>*/</script></p></span>\n        <div>\n        </div>\n      </div></div>\n              </div><div class=\"tab-pane\" id=\"tab608362284-3\">\n              <div>\n      <script data-this=\"{&quot;dataId&quot;:&quot;anonb07561a8d09d7bea3c91c123364f2aa8&quot;,&quot;dataInit&quot;:[{&quot;_1&quot;:0,&quot;_2&quot;:1},{&quot;_1&quot;:1,&quot;_2&quot;:2},{&quot;_1&quot;:2,&quot;_2&quot;:3},{&quot;_1&quot;:3,&quot;_2&quot;:4},{&quot;_1&quot;:4,&quot;_2&quot;:5},{&quot;_1&quot;:5,&quot;_2&quot;:6},{&quot;_1&quot;:6,&quot;_2&quot;:7},{&quot;_1&quot;:7,&quot;_2&quot;:8},{&quot;_1&quot;:8,&quot;_2&quot;:9},{&quot;_1&quot;:9,&quot;_2&quot;:10}],&quot;genId&quot;:&quot;2079717821&quot;}\" type=\"text/x-scoped-javascript\">/*<![CDATA[*/req(['../javascripts/notebook/playground','../javascripts/notebook/magic/barChart'], \n      function(playground, _magicbarChart) {\n        // data ==> data-this (in observable.js's scopedEval) ==> this in JS => { dataId, dataInit, ... }\n        // this ==> scope (in observable.js's scopedEval) ==> this.parentElement ==> div.container below (toHtml)\n\n        playground.call(data,\n                        this\n                        ,\n                        {\n    \"f\": _magicbarChart,\n    \"o\": {\"x\":\"_1\",\"y\":\"_2\",\"width\":600,\"height\":400}\n  }\n  \n                        \n                        \n                      );\n      }\n    );/*]]>*/</script>\n    <div>\n        <p data-bind=\"text: value\"><script data-this=\"{&quot;valueId&quot;:&quot;anon44549a918796d965fe94d6768f704fd1&quot;}\" type=\"text/x-scoped-javascript\">/*<![CDATA[*/\nreq(\n['observable', 'knockout'],\nfunction (O, ko) {\n  ko.applyBindings({\n      value: O.makeObservable(valueId)\n    },\n    this\n  );\n});\n        /*]]>*/</script></p> <span style=\"color:red\"><p data-bind=\"text: value\"><script data-this=\"{&quot;valueId&quot;:&quot;anon7d05fea989515bb87341e3cfaece8cdf&quot;}\" type=\"text/x-scoped-javascript\">/*<![CDATA[*/\nreq(\n['observable', 'knockout'],\nfunction (O, ko) {\n  ko.applyBindings({\n      value: O.makeObservable(valueId)\n    },\n    this\n  );\n});\n        /*]]>*/</script></p></span>\n        <div>\n        </div>\n      </div></div>\n              </div><div class=\"tab-pane\" id=\"tab608362284-4\">\n              <div>\n      <script data-this=\"{&quot;dataId&quot;:&quot;anon639e941919a776cab38cb91937e88d68&quot;,&quot;dataInit&quot;:[{&quot;_1&quot;:0,&quot;_2&quot;:1},{&quot;_1&quot;:1,&quot;_2&quot;:2},{&quot;_1&quot;:2,&quot;_2&quot;:3},{&quot;_1&quot;:3,&quot;_2&quot;:4},{&quot;_1&quot;:4,&quot;_2&quot;:5},{&quot;_1&quot;:5,&quot;_2&quot;:6},{&quot;_1&quot;:6,&quot;_2&quot;:7},{&quot;_1&quot;:7,&quot;_2&quot;:8},{&quot;_1&quot;:8,&quot;_2&quot;:9},{&quot;_1&quot;:9,&quot;_2&quot;:10}],&quot;genId&quot;:&quot;766382692&quot;}\" type=\"text/x-scoped-javascript\">/*<![CDATA[*/req(['../javascripts/notebook/playground','../javascripts/notebook/magic/pivotChart'], \n      function(playground, _magicpivotChart) {\n        // data ==> data-this (in observable.js's scopedEval) ==> this in JS => { dataId, dataInit, ... }\n        // this ==> scope (in observable.js's scopedEval) ==> this.parentElement ==> div.container below (toHtml)\n\n        playground.call(data,\n                        this\n                        ,\n                        {\n    \"f\": _magicpivotChart,\n    \"o\": {\"width\":600,\"height\":400,\"derivedAttributes\":{},\"extraOptions\":{}}\n  }\n  \n                        \n                        \n                      );\n      }\n    );/*]]>*/</script>\n    <div>\n        <p data-bind=\"text: value\"><script data-this=\"{&quot;valueId&quot;:&quot;anon43c5bc76387b80d216eec9d409cc4950&quot;}\" type=\"text/x-scoped-javascript\">/*<![CDATA[*/\nreq(\n['observable', 'knockout'],\nfunction (O, ko) {\n  ko.applyBindings({\n      value: O.makeObservable(valueId)\n    },\n    this\n  );\n});\n        /*]]>*/</script></p> <span style=\"color:red\"><p data-bind=\"text: value\"><script data-this=\"{&quot;valueId&quot;:&quot;anon169e5a1432ca22a08a8705655205d1f9&quot;}\" type=\"text/x-scoped-javascript\">/*<![CDATA[*/\nreq(\n['observable', 'knockout'],\nfunction (O, ko) {\n  ko.applyBindings({\n      value: O.makeObservable(valueId)\n    },\n    this\n  );\n});\n        /*]]>*/</script></p></span>\n        <div>\n        </div>\n      </div></div>\n              </div></div>\n        </div>\n      </div></div>"
      },
      "output_type" : "execute_result",
      "execution_count" : 71
    } ]
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "presentation" : {
        "tabs_state" : "{\n  \"tab_id\": \"#tab893282185-0\"\n}",
        "pivot_chart_state" : "{\n  \"hiddenAttributes\": [],\n  \"menuLimit\": 200,\n  \"cols\": [],\n  \"rows\": [],\n  \"vals\": [],\n  \"exclusions\": {},\n  \"inclusions\": {},\n  \"unusedAttrsVertical\": 85,\n  \"autoSortUnusedAttrs\": false,\n  \"inclusionsInfo\": {},\n  \"aggregatorName\": \"Count\",\n  \"rendererName\": \"Table\"\n}"
      },
      "id" : "9A93F6D0AB394275971A1EF8F7F39925"
    },
    "cell_type" : "code",
    "source" : "1 to 10 by 3",
    "outputs" : [ {
      "name" : "stdout",
      "output_type" : "stream",
      "text" : "res120: scala.collection.immutable.Range = Range(1, 4, 7, 10)\n"
    }, {
      "metadata" : { },
      "data" : {
        "text/html" : "<div>\n      <script data-this=\"{&quot;dataId&quot;:&quot;anon412d734683f9fd47e8932a7d3ea64939&quot;,&quot;dataInit&quot;:[{&quot;_1&quot;:0,&quot;_2&quot;:1},{&quot;_1&quot;:1,&quot;_2&quot;:4},{&quot;_1&quot;:2,&quot;_2&quot;:7},{&quot;_1&quot;:3,&quot;_2&quot;:10}],&quot;genId&quot;:&quot;893282185&quot;}\" type=\"text/x-scoped-javascript\">/*<![CDATA[*/req(['../javascripts/notebook/playground','../javascripts/notebook/magic/tabs'], \n      function(playground, _magictabs) {\n        // data ==> data-this (in observable.js's scopedEval) ==> this in JS => { dataId, dataInit, ... }\n        // this ==> scope (in observable.js's scopedEval) ==> this.parentElement ==> div.container below (toHtml)\n\n        playground.call(data,\n                        this\n                        ,\n                        {\n    \"f\": _magictabs,\n    \"o\": {}\n  }\n  \n                        \n                        \n                      );\n      }\n    );/*]]>*/</script>\n    <div>\n        <div>\n          <ul class=\"nav nav-tabs\" id=\"ul893282185\"><li>\n                <a href=\"#tab893282185-0\"><i class=\"fa fa-table\"/></a>\n              </li><li>\n                <a href=\"#tab893282185-1\"><i class=\"fa fa-dot-circle-o\"/></a>\n              </li><li>\n                <a href=\"#tab893282185-2\"><i class=\"fa fa-line-chart\"/></a>\n              </li><li>\n                <a href=\"#tab893282185-3\"><i class=\"fa fa-bar-chart\"/></a>\n              </li><li>\n                <a href=\"#tab893282185-4\"><i class=\"fa fa-cubes\"/></a>\n              </li></ul>\n\n          <div class=\"tab-content\" id=\"tab893282185\"><div class=\"tab-pane\" id=\"tab893282185-0\">\n              <div>\n      <script data-this=\"{&quot;dataId&quot;:&quot;anon6dc34f51d13a7134122541ea0915e2a0&quot;,&quot;dataInit&quot;:[{&quot;_1&quot;:0,&quot;_2&quot;:1},{&quot;_1&quot;:1,&quot;_2&quot;:4},{&quot;_1&quot;:2,&quot;_2&quot;:7},{&quot;_1&quot;:3,&quot;_2&quot;:10}],&quot;genId&quot;:&quot;989546650&quot;}\" type=\"text/x-scoped-javascript\">/*<![CDATA[*/req(['../javascripts/notebook/playground','../javascripts/notebook/magic/tableChart'], \n      function(playground, _magictableChart) {\n        // data ==> data-this (in observable.js's scopedEval) ==> this in JS => { dataId, dataInit, ... }\n        // this ==> scope (in observable.js's scopedEval) ==> this.parentElement ==> div.container below (toHtml)\n\n        playground.call(data,\n                        this\n                        ,\n                        {\n    \"f\": _magictableChart,\n    \"o\": {\"headers\":[\"_1\",\"_2\"],\"width\":600,\"height\":400}\n  }\n  \n                        \n                        \n                      );\n      }\n    );/*]]>*/</script>\n    <div>\n        <p data-bind=\"text: value\"><script data-this=\"{&quot;valueId&quot;:&quot;anon95402414ddb990477c900039ac91705a&quot;}\" type=\"text/x-scoped-javascript\">/*<![CDATA[*/\nreq(\n['observable', 'knockout'],\nfunction (O, ko) {\n  ko.applyBindings({\n      value: O.makeObservable(valueId)\n    },\n    this\n  );\n});\n        /*]]>*/</script></p> <span style=\"color:red\"><p data-bind=\"text: value\"><script data-this=\"{&quot;valueId&quot;:&quot;anonf5c35a11131341653cd8c9b64654293d&quot;}\" type=\"text/x-scoped-javascript\">/*<![CDATA[*/\nreq(\n['observable', 'knockout'],\nfunction (O, ko) {\n  ko.applyBindings({\n      value: O.makeObservable(valueId)\n    },\n    this\n  );\n});\n        /*]]>*/</script></p></span>\n        <div>\n        </div>\n      </div></div>\n              </div><div class=\"tab-pane\" id=\"tab893282185-1\">\n              <div>\n      <script data-this=\"{&quot;dataId&quot;:&quot;anonec7bd6ca7321da119c97ee45a21455b1&quot;,&quot;dataInit&quot;:[{&quot;_1&quot;:0,&quot;_2&quot;:1},{&quot;_1&quot;:1,&quot;_2&quot;:4},{&quot;_1&quot;:2,&quot;_2&quot;:7},{&quot;_1&quot;:3,&quot;_2&quot;:10}],&quot;genId&quot;:&quot;2018303609&quot;}\" type=\"text/x-scoped-javascript\">/*<![CDATA[*/req(['../javascripts/notebook/playground','../javascripts/notebook/magic/scatterChart'], \n      function(playground, _magicscatterChart) {\n        // data ==> data-this (in observable.js's scopedEval) ==> this in JS => { dataId, dataInit, ... }\n        // this ==> scope (in observable.js's scopedEval) ==> this.parentElement ==> div.container below (toHtml)\n\n        playground.call(data,\n                        this\n                        ,\n                        {\n    \"f\": _magicscatterChart,\n    \"o\": {\"x\":\"_1\",\"y\":\"_2\",\"width\":600,\"height\":400}\n  }\n  \n                        \n                        \n                      );\n      }\n    );/*]]>*/</script>\n    <div>\n        <p data-bind=\"text: value\"><script data-this=\"{&quot;valueId&quot;:&quot;anonaec7531bcbb964808eacd8875be12fa0&quot;}\" type=\"text/x-scoped-javascript\">/*<![CDATA[*/\nreq(\n['observable', 'knockout'],\nfunction (O, ko) {\n  ko.applyBindings({\n      value: O.makeObservable(valueId)\n    },\n    this\n  );\n});\n        /*]]>*/</script></p> <span style=\"color:red\"><p data-bind=\"text: value\"><script data-this=\"{&quot;valueId&quot;:&quot;anoneb19763496ca3df7e9e22d1fc36694f3&quot;}\" type=\"text/x-scoped-javascript\">/*<![CDATA[*/\nreq(\n['observable', 'knockout'],\nfunction (O, ko) {\n  ko.applyBindings({\n      value: O.makeObservable(valueId)\n    },\n    this\n  );\n});\n        /*]]>*/</script></p></span>\n        <div>\n        </div>\n      </div></div>\n              </div><div class=\"tab-pane\" id=\"tab893282185-2\">\n              <div>\n      <script data-this=\"{&quot;dataId&quot;:&quot;anona2f3ed92216bb735cb51ce29b532bd32&quot;,&quot;dataInit&quot;:[{&quot;_1&quot;:0,&quot;_2&quot;:1},{&quot;_1&quot;:1,&quot;_2&quot;:4},{&quot;_1&quot;:2,&quot;_2&quot;:7},{&quot;_1&quot;:3,&quot;_2&quot;:10}],&quot;genId&quot;:&quot;2064252844&quot;}\" type=\"text/x-scoped-javascript\">/*<![CDATA[*/req(['../javascripts/notebook/playground','../javascripts/notebook/magic/lineChart'], \n      function(playground, _magiclineChart) {\n        // data ==> data-this (in observable.js's scopedEval) ==> this in JS => { dataId, dataInit, ... }\n        // this ==> scope (in observable.js's scopedEval) ==> this.parentElement ==> div.container below (toHtml)\n\n        playground.call(data,\n                        this\n                        ,\n                        {\n    \"f\": _magiclineChart,\n    \"o\": {\"x\":\"_1\",\"y\":\"_2\",\"width\":600,\"height\":400}\n  }\n  \n                        \n                        \n                      );\n      }\n    );/*]]>*/</script>\n    <div>\n        <p data-bind=\"text: value\"><script data-this=\"{&quot;valueId&quot;:&quot;anone69d91da56917f852f28eb0589c87645&quot;}\" type=\"text/x-scoped-javascript\">/*<![CDATA[*/\nreq(\n['observable', 'knockout'],\nfunction (O, ko) {\n  ko.applyBindings({\n      value: O.makeObservable(valueId)\n    },\n    this\n  );\n});\n        /*]]>*/</script></p> <span style=\"color:red\"><p data-bind=\"text: value\"><script data-this=\"{&quot;valueId&quot;:&quot;anon0c6fa9312a861624b8f30102414725de&quot;}\" type=\"text/x-scoped-javascript\">/*<![CDATA[*/\nreq(\n['observable', 'knockout'],\nfunction (O, ko) {\n  ko.applyBindings({\n      value: O.makeObservable(valueId)\n    },\n    this\n  );\n});\n        /*]]>*/</script></p></span>\n        <div>\n        </div>\n      </div></div>\n              </div><div class=\"tab-pane\" id=\"tab893282185-3\">\n              <div>\n      <script data-this=\"{&quot;dataId&quot;:&quot;anon3ce54b0889fcf35f429d5c5462b009f6&quot;,&quot;dataInit&quot;:[{&quot;_1&quot;:0,&quot;_2&quot;:1},{&quot;_1&quot;:1,&quot;_2&quot;:4},{&quot;_1&quot;:2,&quot;_2&quot;:7},{&quot;_1&quot;:3,&quot;_2&quot;:10}],&quot;genId&quot;:&quot;1748879296&quot;}\" type=\"text/x-scoped-javascript\">/*<![CDATA[*/req(['../javascripts/notebook/playground','../javascripts/notebook/magic/barChart'], \n      function(playground, _magicbarChart) {\n        // data ==> data-this (in observable.js's scopedEval) ==> this in JS => { dataId, dataInit, ... }\n        // this ==> scope (in observable.js's scopedEval) ==> this.parentElement ==> div.container below (toHtml)\n\n        playground.call(data,\n                        this\n                        ,\n                        {\n    \"f\": _magicbarChart,\n    \"o\": {\"x\":\"_1\",\"y\":\"_2\",\"width\":600,\"height\":400}\n  }\n  \n                        \n                        \n                      );\n      }\n    );/*]]>*/</script>\n    <div>\n        <p data-bind=\"text: value\"><script data-this=\"{&quot;valueId&quot;:&quot;anon7992630de971640cb96d7adc682d7b96&quot;}\" type=\"text/x-scoped-javascript\">/*<![CDATA[*/\nreq(\n['observable', 'knockout'],\nfunction (O, ko) {\n  ko.applyBindings({\n      value: O.makeObservable(valueId)\n    },\n    this\n  );\n});\n        /*]]>*/</script></p> <span style=\"color:red\"><p data-bind=\"text: value\"><script data-this=\"{&quot;valueId&quot;:&quot;anon133622b2396de212353c038571cb8923&quot;}\" type=\"text/x-scoped-javascript\">/*<![CDATA[*/\nreq(\n['observable', 'knockout'],\nfunction (O, ko) {\n  ko.applyBindings({\n      value: O.makeObservable(valueId)\n    },\n    this\n  );\n});\n        /*]]>*/</script></p></span>\n        <div>\n        </div>\n      </div></div>\n              </div><div class=\"tab-pane\" id=\"tab893282185-4\">\n              <div>\n      <script data-this=\"{&quot;dataId&quot;:&quot;anonee7072c4414ad5388d35b85f6cb9184b&quot;,&quot;dataInit&quot;:[{&quot;_1&quot;:0,&quot;_2&quot;:1},{&quot;_1&quot;:1,&quot;_2&quot;:4},{&quot;_1&quot;:2,&quot;_2&quot;:7},{&quot;_1&quot;:3,&quot;_2&quot;:10}],&quot;genId&quot;:&quot;705092812&quot;}\" type=\"text/x-scoped-javascript\">/*<![CDATA[*/req(['../javascripts/notebook/playground','../javascripts/notebook/magic/pivotChart'], \n      function(playground, _magicpivotChart) {\n        // data ==> data-this (in observable.js's scopedEval) ==> this in JS => { dataId, dataInit, ... }\n        // this ==> scope (in observable.js's scopedEval) ==> this.parentElement ==> div.container below (toHtml)\n\n        playground.call(data,\n                        this\n                        ,\n                        {\n    \"f\": _magicpivotChart,\n    \"o\": {\"width\":600,\"height\":400,\"derivedAttributes\":{},\"extraOptions\":{}}\n  }\n  \n                        \n                        \n                      );\n      }\n    );/*]]>*/</script>\n    <div>\n        <p data-bind=\"text: value\"><script data-this=\"{&quot;valueId&quot;:&quot;anone6e9070b411573e925013c3a23ee4798&quot;}\" type=\"text/x-scoped-javascript\">/*<![CDATA[*/\nreq(\n['observable', 'knockout'],\nfunction (O, ko) {\n  ko.applyBindings({\n      value: O.makeObservable(valueId)\n    },\n    this\n  );\n});\n        /*]]>*/</script></p> <span style=\"color:red\"><p data-bind=\"text: value\"><script data-this=\"{&quot;valueId&quot;:&quot;anonde09d1f6e8fef73884413be5cbd7fef4&quot;}\" type=\"text/x-scoped-javascript\">/*<![CDATA[*/\nreq(\n['observable', 'knockout'],\nfunction (O, ko) {\n  ko.applyBindings({\n      value: O.makeObservable(valueId)\n    },\n    this\n  );\n});\n        /*]]>*/</script></p></span>\n        <div>\n        </div>\n      </div></div>\n              </div></div>\n        </div>\n      </div></div>"
      },
      "output_type" : "execute_result",
      "execution_count" : 72
    } ]
  }, {
    "metadata" : {
      "id" : "D7A021C377D840358578268423571D28"
    },
    "cell_type" : "markdown",
    "source" : "When you need a small test data set to play with Spark, ranges can be convenient."
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "id" : "14F278432C3D46ED8F3A8C282A27C71A"
    },
    "cell_type" : "code",
    "source" : "val rdd7 = sc.parallelize(1 to 50).\n    map(i => (i, i%7)).\n    groupBy{ case (i, seven) => seven }.\n    sortByKey()\nrdd7.take(7).foreach(println)",
    "outputs" : [ {
      "name" : "stdout",
      "output_type" : "stream",
      "text" : "(0,CompactBuffer((7,0), (14,0), (21,0), (28,0), (35,0), (42,0), (49,0)))\n(1,CompactBuffer((1,1), (8,1), (15,1), (22,1), (29,1), (36,1), (43,1), (50,1)))\n(2,CompactBuffer((2,2), (9,2), (16,2), (23,2), (30,2), (37,2), (44,2)))\n(3,CompactBuffer((3,3), (10,3), (17,3), (24,3), (31,3), (38,3), (45,3)))\n(4,CompactBuffer((4,4), (11,4), (18,4), (25,4), (32,4), (39,4), (46,4)))\n(5,CompactBuffer((5,5), (12,5), (19,5), (26,5), (33,5), (40,5), (47,5)))\n(6,CompactBuffer((6,6), (13,6), (20,6), (27,6), (34,6), (41,6), (48,6)))\nrdd7: org.apache.spark.rdd.RDD[(Int, Iterable[(Int, Int)])] = ShuffledRDD[82] at sortByKey at <console>:71\n"
    }, {
      "metadata" : { },
      "data" : {
        "text/html" : ""
      },
      "output_type" : "execute_result",
      "execution_count" : 75
    } ]
  }, {
    "metadata" : {
      "id" : "CB6562E464EC41A2ABD7CDE4246BBBA4"
    },
    "cell_type" : "markdown",
    "source" : "[SparkContext](http://spark.apache.org/docs/latest/api/scala/index.html#org.apache.spark.SparkContext) also has a `range` method that effectively does the same thing as `sc.parallelize(some_range)`."
  }, {
    "metadata" : {
      "id" : "797990BEF349442581344872D613911F"
    },
    "cell_type" : "markdown",
    "source" : "### Scala Interpreter (REPL) vs. Notebooks vs. Scala Compiler\n<a name=\"REPL\"></a>\nThis notebook has been using a running Scala interpreter, a.k.a. _REPL_ (\"read, eval, print, loop\") to parse the Scala code. The Spark distribution comes with a `spark-shell` script that also lets you use the interpreter from the command line, but without the nice notebook UI.\n\nIf you use `spark-shell`, there are a few other behavior changes you should know about."
  }, {
    "metadata" : {
      "id" : "E5C679DF0C204FD48041407DD1AA339A"
    },
    "cell_type" : "markdown",
    "source" : "#### Using :paste Mode\nBy default the Scala interpreter treats _each line_ you enter separately. This can cause surprises compared to how the Scala _compiler_ works, where it treats all the code in the same file in the same context.\n\nFor example, the following code, where the expression continues on the second line, is handled successfully by the compiler, but not by the interpreter.\n\n```scala\n(1 to 100)\n.map(i => i*i)\n```\n\nthe Interpreter thinks it finished parsing the expression when it hit the new line after the literal [Range](http://www.scala-lang.org/api/current/index.html#scala.collection.immutable.Range), `1 to 100`. It then throws an error on the opening `.` on the next line. On the other hand, the compiler keeps compiling, ignoring the new line in this case. \n\nThis notebook also does the same thing as the \"raw\" interpreter, but in some cases, notebooks will use an interpeter command, `:paste` that tells the parser to parse all of the lines that follow together, just like the compiler would parse them, until the \"end of input\", which you indicate with `CTRL-D`. \n\nYou can't experiment with it through this notebook, but your session would look something like this:\n\n```scala\nscala> :paste\n// Entering paste mode (ctrl-D to finish)\n\n(1 to 10)\n.map(i => i*i)\n<CTRL-D>\n\n// Exiting paste mode, now interpreting.\n\nres0: scala.collection.immutable.IndexedSeq[Int] = Vector(1, 4, 9, 16, 25, 36, 49, 64, 81, 100)\n\nscala>\n```"
  }, {
    "metadata" : {
      "id" : "E214F5D1B4184A8383B4A84A823A1729"
    },
    "cell_type" : "markdown",
    "source" : "#### Ambiguities with Companion Objects\n<a name=\"Ambiguities\"></a>\nAs I wrote this notebook, I _wanted_ to demonstrate using the companion object `IIRecord` to define a method explicitly, but this leads to an ambiguity later on in the notebook if you attempt to use this method. The notebook gets confused between the case class and the object. \n\nWhile unfortunate, it's also true that once you start defining more involved case classes, with more than trivial methods and explicit additions to the default companion object, you should really define these types outside the notebook in a compiled library that you use within the notebook.\n\nThe details are beyond our scope here, but basically, you set up a project with your Scala code and build it using your favorite build tool. [SBT](http://www.scala-sbt.org/) is a popular choice for Scala, but Maven, Gradle, etc. can be used. \n\nYou want to generate a _jar_ file with the compiled artifacts, then when you start `spark-shell`, submit a Spark job with `spark-submit` or use a notebook environment like this one, you specify the jar for inclusion. For `spark-shell` and `spark-submit`, invoke it with the `--jars myproject.jar` option. For Toree with Jupyter, see the discussion on the [FAQ page](https://toree.incubator.apache.org/documentation/user/faq.html)."
  }, {
    "metadata" : {
      "id" : "309C64A9379541BEBF998A39DD9DB5E4"
    },
    "cell_type" : "markdown",
    "source" : "### Scala's Type Hierarchy\nScala's type hierarchy is similar to Java's, but with some interesting differences."
  }, {
    "metadata" : {
      "id" : "302080EB350C4C928853154BD88D660D"
    },
    "cell_type" : "markdown",
    "source" : "![Scala Type Hierarchy](http://docs.scala-lang.org/resources/images/classhierarchy.img_assist_custom.png)"
  }, {
    "metadata" : {
      "id" : "C8375B83CD0247C6BEE98E1DF8CDD0EF"
    },
    "cell_type" : "markdown",
    "source" : "In Java, all _reference types_ are descended from [java.lang.Object](https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html). The name _reference type_ reflects the fact that the instances for all these types are allocated on the _heap_ and program variables are references to those heap locations.\n\nThe primitives types, `int`, `long`, etc. are not considered part of the type hierarchy and are treated specially. This is in part a performance optimization, as instances of these types fit in CPU registers and the values are pushed onto stack frames. However, they have wrapper or \"boxed\" types, `Integer`, `Long`, etc., that are part of the type hierarchy, which you must use with Java's collections, for example (with the exception of arrays).\n\nInstead, Scala treats the primitives at the code level as basically the same as the reference types. You don't use `new Int(100)` for example, but you can call methods on `Int` instances. The code generated, in most cases, uses the optimized JVM primitives. \n\nHence, the Scala type hierarchy defines a type [Any](http://www.scala-lang.org/api/current/#scala.Any) to be the a parent type of _both_ reference types and \"value\" types (for the primitives). Each of those subhierarchies have parent types, [AnyRef](http://www.scala-lang.org/api/current/#scala.AnyRef) is effectively the same as [java.lang.Object](https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html), and [AnyVal](http://www.scala-lang.org/api/current/#scala.AnyVal) is the parent of the value types.\n\nFinally, for better \"soundness\", the Scala type system defines a real type to represent [Null](http://www.scala-lang.org/api/current/#scala.Null) and [Nothing](http://www.scala-lang.org/api/current/#scala.Nothing). By defining `Null` to be the subtype of all reference types `AnyRefs` (but not `AnyVals`), it supports at the type level the (unfortunate) practice of using `null` for a reference value.\n\nHowever, `null` is not allowed for an `AnyVal`, so the true \"bottom type\" of the hierarchy is `Nothing`. Why is that useful. I'll explain in the next section."
  }, {
    "metadata" : {
      "id" : "5D85EDA6B1E340D49CA04EB1B8379A1D"
    },
    "cell_type" : "markdown",
    "source" : "### Try vs. Option vs. null\n<a name=\"TryOptionNull\"></a>\n\nRecall the signature of our `curl` method near the beginning of this notebook:\n\n```scala\ndef curl(sourceURLString: String, targetDirectoryString: String): Try[File] = ...\n```\n\nWe explained briefly why we used `Try`. Let's explore it in more detail and also discuss an alternative, [Option](http://www.scala-lang.org/api/current/index.html#scala.Option)."
  }, {
    "metadata" : {
      "id" : "EA03F2FA02244AF989A920AC520BA08E"
    },
    "cell_type" : "markdown",
    "source" : "Because `curl` is declared to return [util.Try[T]](http://www.scala-lang.org/api/current/index.html#scala.util.Try), where `T` is `java.io.File` in this case, the reader knows that it might fail somehow. If so, the relevant exception will be returned wrapped in a subclass of `Try`, called [util.Failure[T]](http://www.scala-lang.org/api/current/index.html#scala.util.Failure). However, if `curl` is successful, the `File` is returned wrapped in the other subclass of `Try`, [util.Success[T]](http://www.scala-lang.org/api/current/index.html#scala.util.Success),\n\nBecause of Scala's type safety, you must determine which result was returned and handle it appropriately. Consider the alternative that's popular in many languages, including Java. Here's a `curl2` declaration, that returns `File` instead:\n\n```scala\ndef curl2(sourceURLString: String, targetDirectoryString: String): File = ...\n```\n\nNow, the return type tells you nothing about the possibility of failure. In Java, you might declare that one of several exceptions might be thrown; this isn't done in Scala. Instead, we use the return type to convey this information. So which is better? The problem with declaring `File` as the return type is that `curl2` has no choice but to return `null` if failure occurs but an exception isn't thrown. Unless we remember to check for `null`, we'll get the infamous [NullPointerException](https://docs.oracle.com/javase/8/docs/api/java/lang/NullPointerException.html). So, using `Try[T]` prevents us from this loophole.\n\nUsing `Try` rather than simply throwing an exception, means that `curl` always returns \"normally\", so the caller maintains full control of the call stack and special exception-catching logic isn't required."
  }, {
    "metadata" : {
      "id" : "02910EB617EE423582DC23CAB4FBE5F6"
    },
    "cell_type" : "markdown",
    "source" : "What are all the possible valid subclasses of `Try`? Really, there are only two, `Success` and `Failure`. It would be a mistake to allow a user to define other subtypes, like `MaybeCouldFailButWhoKnows`, because users of `Try` in pattern matching will always want to know that there are only two possibilities. Scala adds a keyword to enforce this logical behavior. `Try` is actually declared as follows:\n\n```scala\nsealed abstract class Try[+T] extends AnyRef\n```\n\n(`AnyRef` is the same as Java's `Object` supertype.) The `sealed` keyword says that _no_ subclasses of `Try` can be declared, _except_ in the same source file (which the library author wrote). Hence, users of `Try` can't declare their own subclasses, subverting the logical structure of this type hierarchy and other user's code that relies on this structure."
  }, {
    "metadata" : {
      "id" : "0CA5438E96E34CBC860C65C61DF2B2B8"
    },
    "cell_type" : "markdown",
    "source" : "What if we have a situation where it makes no sense to involve an exception, but we want the same logically handling? This is where [Option[T]](http://www.scala-lang.org/api/current/index.html#scala.Option) comes in. \n\n`Option` is analogous to `Try`, it is a `sealed` abstract type with two possible subtypes:\n\n* [Some[T]](http://www.scala-lang.org/api/current/index.html#scala.None): I have a an instance of `T` for your, inside the `Some[T]`.\n* [None](http://www.scala-lang.org/api/current/index.html#scala.None): I don't have a value for your, sorry.\n\nNote that a hash map is a great example where I either have a value for a given key or I don't. Therefore, for Scala's [Map[K,V]](http://www.scala-lang.org/api/current/index.html#scala.collection.Map) abstraction, where `K` is the key type and `V` is the value type, the `get` method has this signature:\n\n```scala\ndef get(key: K): Option[V]\n```\n\nOne again, you know from the type signature that you may or may not get a value instance for the input key, _and_ you **must** determine whether you got a `Some[V]` or a `None` as the result. Once again, we avoid returning a `null` value and risking a `NullPointerException` if we forget to handle it."
  }, {
    "metadata" : {
      "id" : "000CD7F1DA0647BBBC49DD21B4A5A265"
    },
    "cell_type" : "markdown",
    "source" : "So, how do we determine which `Option[T]` was returned? Let's look a few examples using `Option`. Can you guess what they are doing? Check the [Option Scaladocs](http://www.scala-lang.org/api/current/#scala.Option) to confirm. `Try` can be used similarly, with a few other ways available that we won't discuss here (but see the [Try Scaladocs](http://www.scala-lang.org/api/current/#scala.util.Try))."
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "id" : "417601022616427EA8B7ED8C982C6239"
    },
    "cell_type" : "code",
    "source" : "val options = Seq(None, Some(2), Some(3), None, Some(5))\n\noptions.foreach { o =>\n    println(o.getOrElse(\"None\"))\n}",
    "outputs" : [ {
      "name" : "stdout",
      "output_type" : "stream",
      "text" : "None\n2\n3\nNone\n5\noptions: Seq[Option[Int]] = List(None, Some(2), Some(3), None, Some(5))\n"
    }, {
      "metadata" : { },
      "data" : {
        "text/html" : ""
      },
      "output_type" : "execute_result",
      "execution_count" : 76
    } ]
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "id" : "563BAB96709E407C87098F477544F6E1"
    },
    "cell_type" : "code",
    "source" : "options.foreach {\n    case None    => println(None)\n    case Some(i) => println(i)  // Note how we extract the enclosed value.\n}",
    "outputs" : [ {
      "name" : "stdout",
      "output_type" : "stream",
      "text" : "None\n2\n3\nNone\n5\n"
    }, {
      "metadata" : { },
      "data" : {
        "text/html" : ""
      },
      "output_type" : "execute_result",
      "execution_count" : 77
    } ]
  }, {
    "metadata" : {
      "id" : "01C6A19D2CDF490B8D9A776894CD4C0A"
    },
    "cell_type" : "markdown",
    "source" : "If you just want to ignore the `None` values, use a _for comprehension_. We could print them as before, but this time we'll `yield` each value, constructing a new `Seq` (sequence) of numbers."
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "id" : "0E1BF86C497B43568BC1A7B3B2E92FB5"
    },
    "cell_type" : "code",
    "source" : "val numbers = for {\n    opt   <- options  // loop through the options, assign each to \"option\"\n    value <- opt      // extract the value from the Some, or if None, skip to the next loop\n} yield value",
    "outputs" : [ {
      "name" : "stdout",
      "output_type" : "stream",
      "text" : "numbers: Seq[Int] = List(2, 3, 5)\n"
    }, {
      "metadata" : { },
      "data" : {
        "text/html" : ""
      },
      "output_type" : "execute_result",
      "execution_count" : 91
    } ]
  }, {
    "metadata" : {
      "id" : "183B495289174E1A9D95EEBBBB5C505D"
    },
    "cell_type" : "markdown",
    "source" : "Finally, you might wonder how `None` is declared. Consider this example:"
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "id" : "01EA7C7FFFBE4469A0BDF9D87F283162"
    },
    "cell_type" : "code",
    "source" : "val opts: Seq[Option[String]] = Seq(Some(\"hello\"), None, Some(\"world!\"))\nopts.foreach(println)",
    "outputs" : [ {
      "name" : "stdout",
      "output_type" : "stream",
      "text" : "Some(hello)\nNone\nSome(world!)\nopts: Seq[Option[String]] = List(Some(hello), None, Some(world!))\n"
    }, {
      "metadata" : { },
      "data" : {
        "text/html" : ""
      },
      "output_type" : "execute_result",
      "execution_count" : 92
    } ]
  }, {
    "metadata" : {
      "id" : "041002EBDA9849ADB9D5098ED8A4EEF0"
    },
    "cell_type" : "markdown",
    "source" : "This works, so it must mean that `None` is a valid subclass of `Option[String]`. That's actually true for all `Option[T]`. How can a single object be a valid subtype for _all_ of them? Here is how it's declared (omitting some details):\n\n```scala\nobject None extends Option[Nothing] {...}\n\n```\n\n`None` carries no \"state\" information, because it doesn't wrap an instance like `Some[T]` does. Hence, we only need one instance for all uses, so it's declared as an object. Recall we mentioned above that the type system has a [Nothing](http://www.scala-lang.org/api/current/#scala.Nothing) type, which is a subtype of all other types. Without diving into too many details, if a variable is of type `Option[String]`, then you can use an `Option[Nothing]` for it (i.e., the latter is a subtype of the former). This is why `Nothing` is useful, for cases like `None`, so we can have one instance of it, but still obey the rules of Scala's object-oriented type system."
  }, {
    "metadata" : {
      "id" : "F39CA8B00D7F41C9851C49E0E0D7D5A1"
    },
    "cell_type" : "markdown",
    "source" : "### Implicits\n<a name=\"implicits\"></a>\nScala has a powerful mechanism known as _implicits_ that is used in the Spark Scala API. Implicits are a big topic, so we'll focus just on the uses of it that are most important to understand.  "
  }, {
    "metadata" : {
      "id" : "6C195C1AEB8E471699BB6B4D8541598F"
    },
    "cell_type" : "markdown",
    "source" : "#### Type Conversions\nWe used `RDD` methods like `reduceByKey` above, but if you search for this method in the [RDD Scaladoc page](http://spark.apache.org/docs/latest/api/scala/index.html#org.apache.spark.rdd.RDD), you won't find it. Instead it's defined in the [PairRDDFunctions](http://spark.apache.org/docs/latest/api/scala/index.html#org.apache.spark.rdd.PairRDDFunctions) type (along with all the other `*ByKey` methods). So, how can we use these methods as if they are defined for `RDD`??\n\nWhen the Scala compiler sees code calling a method that doesn't exist on the type, it looks for an _implicit conversion_ in the current scope, which can transform the instance into another type (i.e., by wrapping it), where the other type provides the needed method. The full signature inferred for the method as it's used must match the definition in the wrapping class.\n\n> **Note:** If you don't find a method in the [Spark Scaladocs](http://spark.apache.org/docs/latest/api/scala/index.html#package) for a type where you think it should be defined, look for related helper types with the method.\n\nHere's a small Scala example of how this works:"
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "id" : "9CE1F09078A64727BEE4A59B32F7CC19"
    },
    "cell_type" : "code",
    "source" : "// A sample class. Note it doesn't define a `toJSON` method:\ncase class Person(name: String, age: Int = 0)",
    "outputs" : [ {
      "name" : "stdout",
      "output_type" : "stream",
      "text" : "defined class Person\n"
    }, {
      "metadata" : { },
      "data" : {
        "text/html" : ""
      },
      "output_type" : "execute_result",
      "execution_count" : 93
    } ]
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "id" : "41EBF853BA8E4D2B8C39B66897E45A23"
    },
    "cell_type" : "code",
    "source" : "// To scope them, define implicit conversions within an object\nobject implicits {\n\n    // `implicit` keyword tells the compiler to consider this conversion.\n    // It takes a `Person`, returning a new instance of `PersonToJSONString`,\n    // then resolves the invocation of `toJSON`.\n    implicit class PersonToJSONString(person: Person) {\n        def toJSON: String = s\"\"\"{\"name\": ${person.name}, \"age\": ${person.age}}\"\"\"\n    }\n}\n\nimport implicits._        // Now it is visible in the current scope.\n\nval p = Person(\"Dean Wampler\", 39)\n\n// Magic conversion to `PersonToJSONString`, then `toJSON` is called.\np.toJSON",
    "outputs" : [ {
      "name" : "stdout",
      "output_type" : "stream",
      "text" : "defined object implicits\nimport implicits._\np: Person = Person(Dean Wampler,39)\nres159: String = {\"name\": Dean Wampler, \"age\": 39}\n"
    }, {
      "metadata" : { },
      "data" : {
        "text/html" : ""
      },
      "output_type" : "execute_result",
      "execution_count" : 94
    } ]
  }, {
    "metadata" : {
      "id" : "66E48B7868F94F9383CF62A0BB79F2D0"
    },
    "cell_type" : "markdown",
    "source" : "For `RDDs`, the implicit conversions to `PairRDDFunctions` and other support types are handled for you. However, when you use Spark SQL and the [DataFrame](http://spark.apache.org/docs/latest/api/scala/index.html#org.apache.spark.sql.DataFrame) API, you'll need to import some of these conversions yourself:"
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "id" : "FE77D70EB2CB4434B885E4782A07B97C"
    },
    "cell_type" : "code",
    "source" : "val sqlc = sqlContext\nimport sqlc.implicits._  ",
    "outputs" : [ {
      "name" : "stdout",
      "output_type" : "stream",
      "text" : "sqlc: org.apache.spark.sql.SQLContext = org.apache.spark.sql.SQLContext@26445b16\nimport sqlc.implicits._\n"
    }, {
      "metadata" : { },
      "data" : {
        "text/html" : ""
      },
      "output_type" : "execute_result",
      "execution_count" : 95
    } ]
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "id" : "CC6CE2FC418846DE8E5133836A8AC66C"
    },
    "cell_type" : "code",
    "source" : "val wtc = iiDF.select($\"word\", $\"total_count\")\nwtc.show",
    "outputs" : [ {
      "name" : "stdout",
      "output_type" : "stream",
      "text" : "+-----------+-----------+\n|       word|total_count|\n+-----------+-----------+\n|          a|       3350|\n|    abandon|          6|\n|      abate|          3|\n|  abatement|          1|\n|     abbess|          8|\n|      abbey|          9|\n|abbominable|          1|\n|abbreviated|          1|\n|       abed|          2|\n|   abetting|          1|\n|abhominable|          1|\n|      abhor|          5|\n|     abhors|          2|\n|      abide|          5|\n|     abides|          1|\n|    ability|          2|\n|     abject|          2|\n|     abjure|          1|\n|    abjured|          2|\n|       able|          9|\n+-----------+-----------+\nonly showing top 20 rows\n\nwtc: org.apache.spark.sql.DataFrame = [word: string, total_count: int]\n"
    }, {
      "metadata" : { },
      "data" : {
        "text/html" : ""
      },
      "output_type" : "execute_result",
      "execution_count" : 96
    } ]
  }, {
    "metadata" : {
      "id" : "EC8352A276FA495EB26F84C4B4402E0B"
    },
    "cell_type" : "markdown",
    "source" : "The column-reference syntax `$\"name\"` is implemented using the same mechanism in the Scala library that implements interpolated strings, `s\"$foo\"`. The `import sqlc.implicits._` makes it available. \n\nNote we imported something from an _instance_, rather than a package or type, as allowed in Java. This can be a useful feature in Scala, but it's also fragile, If you try `import sqlContext.implicits._`, you'll get a compiler error that a \"stable identifier\" is required. It turns out that doing the value assignment, `val sqlc = sqlContext` first meets this requirement. This is unique to the notebook environment. You normally won't see this problem if you use the `spark-shell` that comes with a Spark distribution or you write a Spark program and compile it with the Scala compiler.\n\nHowever, it would be better if Spark defined this `implicits` object on the `SQLContext` companion object instead of on instances of it!"
  }, {
    "metadata" : {
      "id" : "AD9665EA860E4C2F8CC2E408C20603F3"
    },
    "cell_type" : "markdown",
    "source" : "For completeness, but unrelated to implicits, the `DataFrame` API lets you write SQL-like queries with a programmatic API. If you want to use built in functions like `min`, `max`, etc. on columns, you need the following `import` statement:"
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "id" : "6F83A0CC81934708ACD1E136CE4F0C1A"
    },
    "cell_type" : "code",
    "source" : "import org.apache.spark.sql.functions._",
    "outputs" : [ {
      "name" : "stdout",
      "output_type" : "stream",
      "text" : "import org.apache.spark.sql.functions._\n"
    }, {
      "metadata" : { },
      "data" : {
        "text/html" : ""
      },
      "output_type" : "execute_result",
      "execution_count" : 97
    } ]
  }, {
    "metadata" : {
      "id" : "C6C9D19C7E9A41D28CECF6E8790D5646"
    },
    "cell_type" : "markdown",
    "source" : "Now we can use `min`, `max`, `avg`, etc."
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "id" : "B2BD1F33FB2E47708D33564A398AA7F1"
    },
    "cell_type" : "code",
    "source" : "val mma = iiDF.select(min(\"total_count\"), max(\"total_count\"), avg(\"total_count\"))\nmma.show",
    "outputs" : [ {
      "name" : "stdout",
      "output_type" : "stream",
      "text" : "+----------------+----------------+------------------+\n|min(total_count)|max(total_count)|  avg(total_count)|\n+----------------+----------------+------------------+\n|               1|            5208|16.651743683350947|\n+----------------+----------------+------------------+\n\nmma: org.apache.spark.sql.DataFrame = [min(total_count): int, max(total_count): int, avg(total_count): double]\n"
    }, {
      "metadata" : { },
      "data" : {
        "text/html" : ""
      },
      "output_type" : "execute_result",
      "execution_count" : 98
    } ]
  }, {
    "metadata" : {
      "id" : "E2ED40DF8736441589E4366F32AE84F8"
    },
    "cell_type" : "markdown",
    "source" : "#### Implicit Method Arguments\nOne other use of implicits worth understanding is _implicit arguments_ to methods. You will encounter this mechanism used when you read the Spark Scaladocs, even though you might never realize you're actually using it in your code!\n\nRecall I mentioned previously that you can define default values for method arguments. I just used it for the `age` argument for `Person`:\n\n```scala\ncase class Person(name: String, age: Int = 0)\n```\n\nSometimes we need something more sophisticated. For example, our library might have a group of methods that need a special argument passed to them that provides useful \"context\" information, but you don't want the user to be required to explicitly pass this argument every time. Other times you might use implicit arguments to make the API \"cleaner\", but still have some control over what's allowed.\n\nHere's an example, that's partly inspired by Scala's [Seq.sum](http://www.scala-lang.org/api/current/#scala.collection.Seq) method. Wouldn't it be great if I happen to have a collection of things I can \"add\" together, if I could just call `sum` on the collection? Let's do this in a slightly different way, with a helper `sum` method outside of `Seq`."
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "id" : "56FAB05720ED42D78975EA9145F27795"
    },
    "cell_type" : "code",
    "source" : "trait Add[T] {\n    def add(t1: T, t2: T): T\n}\n\n// Nested implicits so they don't conflict with the previous object implicits.\nobject Adder {\n    object implicits {\n        implicit val intAdd = new Add[Int] { \n            def add(i1: Int, i2: Int): Int = i1+i2 \n        }\n        implicit val doubleAdd = new Add[Double] { \n            def add(d1: Double, d2: Double): Double = d1+d2 \n        }\n        implicit val stringAdd = new Add[String] { \n            def add(s1: String, s2: String): String = s1+s2 \n        }\n        // etc...\n    }\n}\n\nimport Adder.implicits._\n\n// NOTE: TWO argument lists!\ndef sum[T](ts: Seq[T])(implicit adder: Add[T]): T = {\n    ts.reduceLeft((t1, t2) => adder.add(t1, t2))\n}",
    "outputs" : [ {
      "name" : "stdout",
      "output_type" : "stream",
      "text" : "defined trait Add\ndefined object Adder\nimport Adder.implicits._\nsum: [T](ts: Seq[T])(implicit adder: Add[T])T\n"
    }, {
      "metadata" : { },
      "data" : {
        "text/html" : ""
      },
      "output_type" : "execute_result",
      "execution_count" : 99
    } ]
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "id" : "481097DD68F447E2864FBB4F59EDB8CD"
    },
    "cell_type" : "code",
    "source" : "sum(0 to 10)",
    "outputs" : [ {
      "name" : "stdout",
      "output_type" : "stream",
      "text" : "res168: Int = 55\n"
    }, {
      "metadata" : { },
      "data" : {
        "text/html" : "55"
      },
      "output_type" : "execute_result",
      "execution_count" : 100
    } ]
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "id" : "0AC34A98556444D3ACFFEE51C4685D24"
    },
    "cell_type" : "code",
    "source" : "sum(0.0 to 5.5 by 0.3)",
    "outputs" : [ {
      "name" : "stdout",
      "output_type" : "stream",
      "text" : "res170: Double = 51.29999999999999\n"
    }, {
      "metadata" : { },
      "data" : {
        "text/html" : "51.29999999999999"
      },
      "output_type" : "execute_result",
      "execution_count" : 101
    } ]
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "id" : "282E7CEDA0C645AB8086D547A957B6FC"
    },
    "cell_type" : "code",
    "source" : "sum(Seq(\"one\", \"two\", \"three\"))",
    "outputs" : [ {
      "name" : "stdout",
      "output_type" : "stream",
      "text" : "res172: String = onetwothree\n"
    }, {
      "metadata" : { },
      "data" : {
        "text/html" : "onetwothree"
      },
      "output_type" : "execute_result",
      "execution_count" : 102
    } ]
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "id" : "66BA8398396D47B3B7F6432596396F8E"
    },
    "cell_type" : "code",
    "source" : "// Will fail, because there's not Add[Char] in scope:\nsum(Seq('a', 'b', 'c'))   // Characters",
    "outputs" : [ {
      "name" : "stdout",
      "output_type" : "stream",
      "text" : "<console>:93: error: could not find implicit value for parameter adder: Add[Char]\n       sum(Seq('a', 'b', 'c'))   // Characters\n          ^\n"
    } ]
  }, {
    "metadata" : {
      "id" : "AA7F3CE084AF4EAAADFD1B9460750DF2"
    },
    "cell_type" : "markdown",
    "source" : "So, the implicit values `intAdd`, `doubleAdd`, and `stringAdd`, were used by the Scala interpreter for the `adder` argument in the second _argument list_ for `sum`. Note that you have to use a second argument list and all arguments there must be implicit. \n\nWe could have avoided using implicit arguments if we defined custom `sum` methods for every type. That would have been simpler in this trivial case, but for nontrivial methods, the duplication is worth avoiding. Another advantage of this mechanism is that the user can define her own implicit `Add[T]` instances for domain types (say for example, `Money`) and they would \"just work\".\n\nThe Scala collections API uses this mechanism to know how to construct a new collection of the same kind as the input collection when you use `map`, `flatMap`, `reduceLeft`, etc.\n\nSpark uses this pattern for [Encoders](http://spark.apache.org/docs/latest/api/scala/index.html#org.apache.spark.sql.Encoder) in  Spark SQL. Encoders are used to serialize values into the new, compact memory encoding introduced in the _Tungsten_ project (see for example, [here](https://spark-summit.org/2015/events/deep-dive-into-project-tungsten-bringing-spark-closer-to-bare-metal/)). Here's an example of creating a [Dataset](http://spark.apache.org/docs/latest/api/scala/index.html#org.apache.spark.sql.Dataset), where the `toDS` method is first \"added\" to a Scala [Seq](http://www.scala-lang.org/api/current/#scala.collection.Seq) through an implicit conversion (specifically [SQLImplicits.localSeqToDatasetHolder](http://spark.apache.org/docs/latest/api/scala/index.html#org.apache.spark.sql.SQLImplicits), which is brought into scope by the `import sqlc.implicits._` statement earlier) and then `toDS` uses `Encoders` internally."
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "id" : "934904B8DC224EEC83154CD6149F3AB7"
    },
    "cell_type" : "code",
    "source" : "(0 to 10).toDS()",
    "outputs" : [ {
      "name" : "stdout",
      "output_type" : "stream",
      "text" : "res176: org.apache.spark.sql.Dataset[Int] = [value: int]\n"
    }, {
      "metadata" : { },
      "data" : {
        "text/html" : "[value: int]"
      },
      "output_type" : "execute_result",
      "execution_count" : 104
    } ]
  }, {
    "metadata" : {
      "id" : "A37856B8529E4A5D86C787C595E14FCA"
    },
    "cell_type" : "markdown",
    "source" : "## Conclusions\nI appreciate the effort you put into studying this notebook. I hope you enjoyed it as much as I enjoyed writing it. Please [send me feedback](mailto:dean.wampler@lightbend.com) on how I can improve it! \n\nNow you know the core elements of Scala that you need for using the Spark Scala API. I hope you can appreciate the power and elegance of Scala. I hope you will choose to use it for all of your data engineering tasks, not just for Spark. \n\nWhat about data science? There are many people who use Scala for data science in Spark, but today Python and R have much richer libraries for Mathematics and Machine Learning. That will change over time, but for now, you'll need to decide which language best fits your needs.\n\nAs you use Scala, there will be more things you'll want to understand that we haven't covered, including common idioms, conventions, and tools used in the Scala community. The references at the beginning of the notebook will give you the information you need.\n\nBest wishes.\n\n[Dean Wampler, Ph.D.](mailto:dean.wampler@lightbend.com)<br/>\n[@deanwampler](http://twitter.com/deanwampler)"
  }, {
    "metadata" : {
      "id" : "F824A7CAA46A49BD83A19E9E06399954"
    },
    "cell_type" : "markdown",
    "source" : "## Appendix: Exercise Solutions\n<a name=\"ExerciseSolutions\"></a>\nLet's discuss the solutions to exercises that weren't already solved earlier in the notebook."
  }, {
    "metadata" : {
      "id" : "6D9D398315014C05822F8889BBDA49C2"
    },
    "cell_type" : "markdown",
    "source" : "### Filter for Plays that Have \"of\" in the Name\nYou can add the condition (comment `// <== here`) immediate after defining `play`. You could do it later, after either of the subsequent two expressions, but then you're doing needless computation. Change `true` to `false` to print plays that don't contain \"of\"."
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "id" : "8E63870D6F26419BB1B375463C69009D"
    },
    "cell_type" : "code",
    "source" : "val list2 = for {\n    play <- plays \n    if (play.contains(\"of\") == true)                            // <== here\n    playFileString = targetDirName + pathSeparator + play\n    playFile = new File(playFileString)\n} yield {\n    val successString = if (playFile.exists) \"Success!\" else \"NOT FOUND!!\"\n    \"%-40s\\t%s\".format(playFileString, successString)\n}\nlist2.foreach(println)",
    "outputs" : [ {
      "name" : "stdout",
      "output_type" : "stream",
      "text" : "data/shakespeare/tamingoftheshrew       \tSuccess!\ndata/shakespeare/comedyoferrors         \tSuccess!\ndata/shakespeare/merrywivesofwindsor    \tSuccess!\nlist2: Seq[String] = List(data/shakespeare/tamingoftheshrew       \tSuccess!, data/shakespeare/comedyoferrors         \tSuccess!, data/shakespeare/merrywivesofwindsor    \tSuccess!)\n"
    }, {
      "metadata" : { },
      "data" : {
        "text/html" : ""
      },
      "output_type" : "execute_result",
      "execution_count" : 105
    } ]
  }, {
    "metadata" : {
      "id" : "58DE43817782420189CF9BA4DD12AE5C"
    },
    "cell_type" : "markdown",
    "source" : "### More Specific \"Love\" and \"Hate\" Words\nOne reasonable choice to prevent seeing `glove`, `whatever`, etc. is to only find words that start with `love` and `have`. Let's also keep `unlove`:"
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "id" : "D69DA27B224B40C0A070D64DF221A95D"
    },
    "cell_type" : "code",
    "source" : "val topLocationsLoveHate = sqlContext.sql(\"\"\"\n    SELECT word,  total_count, locations[0] AS top_location, counts[0] AS top_count\n    FROM inverted_index \n    WHERE word LIKE 'love%' OR word LIKE 'unlove%' OR word LIKE 'hate%'\n\"\"\")\ntopLocationsLoveHate.show(40)",
    "outputs" : [ {
      "name" : "stdout",
      "output_type" : "stream",
      "text" : "+-------+-----------+--------------------+---------+\n|   word|total_count|        top_location|top_count|\n+-------+-----------+--------------------+---------+\n|   hate|         22|midsummersnightsd...|        9|\n|  hated|          6|midsummersnightsd...|        4|\n|hateful|          5|midsummersnightsd...|        3|\n|  hates|          5|         asyoulikeit|        2|\n| hateth|          1|midsummersnightsd...|        1|\n|   love|        662|    loveslabourslost|      121|\n|  loved|         38|         asyoulikeit|       13|\n| lovely|         15|midsummersnightsd...|        7|\n|  lover|         33|         asyoulikeit|       14|\n| lovers|         31|midsummersnightsd...|       17|\n|  loves|         51| muchadoaboutnothing|       10|\n| lovest|          8|    tamingoftheshrew|        3|\n| loveth|          2|    loveslabourslost|        1|\n|unloved|          1|midsummersnightsd...|        1|\n+-------+-----------+--------------------+---------+\n\ntopLocationsLoveHate: org.apache.spark.sql.DataFrame = [word: string, total_count: int, top_location: string, top_count: int]\n"
    }, {
      "metadata" : { },
      "data" : {
        "text/html" : ""
      },
      "output_type" : "execute_result",
      "execution_count" : 106
    } ]
  }, {
    "metadata" : {
      "id" : "8ADC76DC45314B31B2D085B78698FE53"
    },
    "cell_type" : "markdown",
    "source" : "### Return the Top Two Locations and Counts\nWe used the `DataFrame` API to write a SQL query that returned the top location and count. Adding the next one is straightforward. What do you observe is returned when there isn't a second location and count?"
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "id" : "83520E5410494DA79BE37C05D8F63A57"
    },
    "cell_type" : "code",
    "source" : "val topTwoLocations = sqlContext.sql(\"\"\"\n    SELECT word, total_count, \n        locations[0] AS first_location,  counts[0] AS first_count,\n        locations[1] AS second_location, counts[1] AS second_count\n    FROM inverted_index \n    WHERE word LIKE '%love%' OR word LIKE '%hate%'\n\"\"\")\ntopTwoLocations.show(100)",
    "outputs" : [ {
      "name" : "stdout",
      "output_type" : "stream",
      "text" : "+--------+-----------+--------------------+-----------+--------------------+------------+\n|    word|total_count|      first_location|first_count|     second_location|second_count|\n+--------+-----------+--------------------+-----------+--------------------+------------+\n| beloved|         11|    tamingoftheshrew|          4|         asyoulikeit|           3|\n|  cloven|          1|    loveslabourslost|          1|                null|        null|\n|  cloves|          1|    loveslabourslost|          1|                null|        null|\n|   glove|          3|    loveslabourslost|          2|        twelfthnight|           1|\n|  glover|          1| merrywivesofwindsor|          1|                null|        null|\n|  gloves|          5| merrywivesofwindsor|          3|         asyoulikeit|           1|\n|    hate|         22|midsummersnightsd...|          9|         asyoulikeit|           6|\n|   hated|          6|midsummersnightsd...|          4|         asyoulikeit|           2|\n| hateful|          5|midsummersnightsd...|          3|    loveslabourslost|           1|\n|   hates|          5|         asyoulikeit|          2| merrywivesofwindsor|           1|\n|  hateth|          1|midsummersnightsd...|          1|                null|        null|\n|    love|        662|    loveslabourslost|        121|         asyoulikeit|         119|\n|   loved|         38|         asyoulikeit|         13| muchadoaboutnothing|          13|\n|  lovely|         15|midsummersnightsd...|          7|    tamingoftheshrew|           5|\n|   lover|         33|         asyoulikeit|         14|midsummersnightsd...|          10|\n|  lovers|         31|midsummersnightsd...|         17|         asyoulikeit|           6|\n|   loves|         51| muchadoaboutnothing|         10| merrywivesofwindsor|           9|\n|  lovest|          8|    tamingoftheshrew|          3| muchadoaboutnothing|           2|\n|  loveth|          2|    loveslabourslost|          1|    tamingoftheshrew|           1|\n| unloved|          1|midsummersnightsd...|          1|                null|        null|\n|   whate|          4|    tamingoftheshrew|          3|         asyoulikeit|           1|\n|whatever|          1|    tamingoftheshrew|          1|                null|        null|\n+--------+-----------+--------------------+-----------+--------------------+------------+\n\ntopTwoLocations: org.apache.spark.sql.DataFrame = [word: string, total_count: int, first_location: string, first_count: int, second_location: string, second_count: int]\n"
    }, {
      "metadata" : { },
      "data" : {
        "text/html" : ""
      },
      "output_type" : "execute_result",
      "execution_count" : 108
    } ]
  }, {
    "metadata" : {
      "id" : "A12E1200260C4F43890B3B7C9F8801EF"
    },
    "cell_type" : "markdown",
    "source" : "### Removing Stop Words\nRecall you were asked to implement a `keep(word: String):Boolean` method that filters stop words.\n\nFirst, let's implement `keep`. You can find lists of stop words on the web. One such list for English can be found [here]( * From http://norm.al/2009/04/14/list-of-english-stop-words/). It includes many words that you might not consider stop words. Nevertheless, I'll just use a smaller list here.\n\nNote that I'll use a Scala [Set](http://www.scala-lang.org/api/current/index.html#scala.collection.immutable.Set) to hold the stop words. We want _O(1)_ look-up performance. We just want to know if the word is in the set or not.\n\nI'll also add \"\", so I can remove the explicit test for it.\n\nFinally, we'll embed the whole thing in a new Scala `object`. This extra encapsulation is a way to work around occasional problems with \"task not serializable\" errors."
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "id" : "1E1181BF7B5D43B28638787497FE37B1"
    },
    "cell_type" : "code",
    "source" : "// NOTE: Put helpers like this in a separate object. This minimizes the risk of\n// \"task not serializable\" errors when running Spark.\nobject keep {\n    val stopWords = Set(\"\", \"a\", \"an\", \"and\", \"I\", \"he\", \"she\", \"it\", \"the\")\n\n    /**\n     * If the set contains the word, we return false - we don't want to keep it!\n     * Note we assume the word has already been converted to lower case!\n     */\n    def apply(word: String): Boolean = stopWords.contains(word) == false  \n}\n\nobject IIStopWords {\n\n    def compute(sc: org.apache.spark.SparkContext, input: String) = {\n        sc.wholeTextFiles(input).\n        flatMap {\n            case (location, contents) => \n                val words = contents.split(\"\"\"\\W+\"\"\").\n                    map(word => word.toLowerCase).  // Do this early, before keep()\n                    filter(word => keep(word))      // <== filter here\n                val fileName = location.split(java.io.File.separator).last\n                words.map(word => ((word, fileName), 1))\n        }.\n        reduceByKey((count1, count2) => count1 + count2).\n        map { \n            case ((word, fileName), count) => (word, (fileName, count)) \n        }.\n        groupByKey.\n        sortByKey(ascending = true).\n        map { \n            case (word, iterable) => \n                val vect = iterable.toVector.sortBy { \n                    case (fileName, count) => (-count, fileName) \n                }\n                val (locations, counts) = vect.unzip  \n                val totalCount = counts.reduceLeft((n1,n2) => n1+n2)        \n                (word, totalCount, locations, counts)\n        }\n    }\n}",
    "outputs" : [ {
      "name" : "stdout",
      "output_type" : "stream",
      "text" : "defined object keep\ndefined object IIStopWords\n"
    }, {
      "metadata" : { },
      "data" : {
        "text/html" : ""
      },
      "output_type" : "execute_result",
      "execution_count" : 113
    } ]
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : true,
      "id" : "3E5F26CCF308489BAFC2CE5D5DCE34E5"
    },
    "cell_type" : "code",
    "source" : "val iiStopWords = IIStopWords.compute(sc, \"data/shakespeare\")",
    "outputs" : [ ]
  }, {
    "metadata" : {
      "id" : "3A21BDCF674F402883F3B8E70E3E310E"
    },
    "cell_type" : "markdown",
    "source" : "> **NOTE:** If you get an error `org.apache.spark.SparkException: Task not serializable` in the previous cell, even despite the comment about avoiding this problem, it is because of a bug in the way Spark Notebook handles scoping in Scala code. However, as discussed previously, defining whole classes like this is usually best done in libraries that you _use_ in the notebook, where the Scala compiler handles scopes more carefully."
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : true,
      "id" : "F44D9D36301344779B87054C92F313EB"
    },
    "cell_type" : "code",
    "source" : "iiStopWords.take(100).foreach(println)",
    "outputs" : [ ]
  }, {
    "metadata" : {
      "id" : "E1FDAF1071864528A32C3CDC0BE0F5E4"
    },
    "cell_type" : "markdown",
    "source" : "One last thing, we now have `filter(word => keep(word))`, but note how we used `println` in the previous cell to see results. We can do something similar with `filter` and instead write `filter(keep)`. \n\nWhat does this mean exactly? It tells the compiler \"convert the _method_ `keep` to a _function_ and pass that to `filter`.\" This works because `keep` already does what `filter` wants, take a single string argument and return a boolean result.\n\nPassing `keep` is actually different than passing `word => keep(word)`, which is an _anonymous_ function that _calls_ keep. We are using `keep` as the function itself, rather than constructing a function that uses `keep`."
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : true,
      "id" : "DAF26BE7B8964EA186CEE712A7B58ADB"
    },
    "cell_type" : "code",
    "source" : "",
    "outputs" : [ ]
  } ],
  "nbformat" : 4
}